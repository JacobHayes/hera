"""This helps parse out the workflow models from the OpenAPI schema and creates an init only for those models"""

import json
# we want the init of `workflows.models` to have a filtered import of Workflow models
# we can parse out the JSON using the old code and filter on Workflow objects
import os
import sys
from pathlib import Path

import requests

from model_type import ModelType


def get_openapi_spec_url() -> str:
    """Gets the OpenAPI spec URL from argv and returns it"""
    assert len(sys.argv) == 3, "Expected two argv arguments - the Argo OpenAPI spec URL and [workflows|events]"
    return sys.argv[1]


def get_model_type() -> str:
    """Gets the model type to generate from argv and returns it"""
    assert len(sys.argv) == 3, \
        f"Expected two argv arguments - the Argo OpenAPI spec URL and one of: {ModelType.values()}"
    arg = sys.argv[2]
    assert ModelType.is_valid(arg), f"Unsupported model type {arg}, expected one of {ModelType.values()}"
    return arg


def fetch_openapi_spec(url: str) -> dict:
    """Fetches the OpenAPI specification at the given URI"""
    response = requests.get(url)
    if response.ok:
        return response.json()
    raise ValueError(
        f"Did not receive an ok response from fetching the OpenAPI spec payload from url {url}, "
        f"status {response.status_code}"
    )


def get_openapi_definitions(spec: dict) -> dict:
    """Extracts the OpenAPI definitions from the given OpenAPI spec"""
    assert "definitions" in spec, "Expected `definitions` to be part of the spec"
    return spec["definitions"]


def get_refs_from_openapi_definitions(model_type: str, defs: dict) -> list:
    """Extracts the OpenAPI references from the given OpenAPI definitions"""
    result = []
    for k in defs.keys():
        if k.startswith(model_type):
            result.append(k.split(model_type)[-1])
    return result


def filter_refs_on_model_type(refs: list, model_type: str) -> list:
    """Filters the given list of references using the given model type"""
    # TODO: maybe this logic can be a bit more sophisticated
    inclusions = ["events", "event", "eventsource", "sensor"]

    filtered = refs
    events = []
    for inclusion in inclusions:
        if ModelType.is_events_type(model_type):
            for ref in refs:
                if inclusion in ref:
                    events.append(ref)
        else:
            exclusions = [
                "io.k8s.api.core.v1.Event",
                "io.k8s.api.core.v1.EventSeries",
                "io.k8s.api.core.v1.EventSource",
            ]
            filtered = list(filter(lambda r: inclusion not in r and r not in exclusions, filtered))
    if ModelType.is_events_type(model_type):
        return list(set(events))
    return list(set(filtered))


def assemble_root_path_from_model_type(m_type: str) -> str:
    """Assembles the Hera root path from the given models type"""
    return f"hera.{m_type}.models"


def get_import_paths_from_refs(refs: list, root_path: str) -> list:
    """Assembles the Hera import paths from the given list of references"""
    result = []
    for ref in refs:
        split = ref.split(".")
        path, obj = ".".join(split[:-1]), split[-1]
        # these are duplicate objects and cause collisions, so we use extra flags from the import path to denote
        # the differences between them, which helps users avoid import errors
        if obj in ["HTTPHeader", "LogEntry"]:
            alias = f"{split[-2]}{obj}"
            upper_alias = alias[0].upper() + alias[1:]
            obj = f"{obj} as {upper_alias}"

        result.append(f"from {root_path}.{path} import {obj}")
    return result


def write_imports(imports: list, model_type: str, openapi_spec_url: str) -> None:
    """Writes the given imports to the `root_path` models"""
    path = Path(__name__).parent.parent / "src" / "hera" / model_type / "models" / "__init__.py"
    with open(str(path), "w+") as f:
        f.write(
            f'"""Auto-generated model classes\n'
            f'"""\n\n'
            f"# [DO NOT EDIT MANUALLY]\n\n"
            f"# Auto-generated by Hera via `make {model_type}-models`\n"
            f"# OpenAPI spec URL: {openapi_spec_url}\n\n"
        )
        for imp in imports:
            f.write(f"{imp}\n")

        if ModelType.is_events_type(model_type):
            f.write("from hera.events.models.io.argoproj.workflow.v1alpha1 import Item\n")
            f.write("from hera.events.models.io.argoproj.workflow.v1alpha1 import Event\n")
            f.write("from hera.events.models.io.argoproj.workflow.v1alpha1 import EventResponse\n")
            f.write("from hera.events.models.io.argoproj.workflow.v1alpha1 import GetUserInfoResponse\n")
            f.write("from hera.events.models.io.argoproj.workflow.v1alpha1 import InfoResponse\n")
            f.write("from hera.events.models.io.argoproj.workflow.v1alpha1 import Version\n")

        if ModelType.is_events_type(model_type) or ModelType.is_workflow_type(model_type):
            enums = [
                "ImagePullPolicy",
                "TerminationMessagePolicy",
                "Protocol",
                "Scheme",
                "Operator",
                "Type",
                "Phase",
                "TypeModel",
                "Effect",
                "OperatorModel",
            ]
            for enum in enums:
                f.write(f"from hera.{model_type}.models.io.k8s.api.core.v1 import {enum}\n")


# Ensure that an init file is present in every folder recursively inside the hera/<model_type>/models folder
# This is to ensure that stubgen works appropriately
def ensure_init():
    for model_type in ModelType.values():
        if not Path(f"src/hera/{model_type}/models").is_dir():
            continue  # skip non-existing directories
        for root, _, files in os.walk(f"src/hera/{model_type}/models"):
            # ignore __pycache__ folders
            if "__pycache__" in root:
                continue
            if "__init__.py" not in files:
                with open(f"{root}/__init__.py", "w") as f:
                    f.write("")


if __name__ == "__main__":
    # model_type = get_model_type()
    model_type = "account"
    # openapi_spec_url = get_openapi_spec_url()
    openapi_spec_url = "LOCAL"
    # openapi_spec = fetch_openapi_spec(openapi_spec_url)
    openapi_spec = json.load(open("/Users/flaviuvadan/projects/hera-workflows/argo-cd-openapi.json"))

    definitions = get_openapi_definitions(openapi_spec)
    refs = get_refs_from_openapi_definitions(model_type, definitions)
    filtered_refs = filter_refs_on_model_type(refs, model_type)
    root_path = assemble_root_path_from_model_type(model_type)
    imports = get_import_paths_from_refs(filtered_refs, root_path)
    write_imports(imports, model_type, openapi_spec_url)
