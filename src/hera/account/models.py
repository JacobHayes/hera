# generated by datamodel-codegen:
#   filename:  argo-cd-openapi.json

from __future__ import annotations

from typing import Any, Dict, List, Optional

from hera.shared._base_model import BaseModel
from pydantic import Field


class Model(BaseModel):
    __root__: Any


class AccountCanIResponse(BaseModel):
    value: Optional[str] = None


class AccountCreateTokenRequest(BaseModel):
    expires_in: Optional[str] = Field(None, alias='expiresIn', title='expiresIn represents a duration in seconds')
    id: Optional[str] = None
    name: Optional[str] = None


class AccountCreateTokenResponse(BaseModel):
    token: Optional[str] = None


class AccountEmptyResponse(BaseModel):
    pass


class AccountToken(BaseModel):
    expires_at: Optional[str] = Field(None, alias='expiresAt')
    id: Optional[str] = None
    issued_at: Optional[str] = Field(None, alias='issuedAt')


class AccountUpdatePasswordRequest(BaseModel):
    current_password: Optional[str] = Field(None, alias='currentPassword')
    name: Optional[str] = None
    new_password: Optional[str] = Field(None, alias='newPassword')


class AccountUpdatePasswordResponse(BaseModel):
    pass


class ApplicationApplicationManifestQueryWithFiles(BaseModel):
    app_namespace: Optional[str] = Field(None, alias='appNamespace')
    checksum: Optional[str] = None
    name: Optional[str] = None


class ApplicationApplicationPatchRequest(BaseModel):
    app_namespace: Optional[str] = Field(None, alias='appNamespace')
    name: Optional[str] = None
    patch: Optional[str] = None
    patch_type: Optional[str] = Field(None, alias='patchType')


class ApplicationApplicationResourceResponse(BaseModel):
    manifest: Optional[str] = None


class ApplicationApplicationResponse(BaseModel):
    pass


class ApplicationApplicationRollbackRequest(BaseModel):
    app_namespace: Optional[str] = Field(None, alias='appNamespace')
    dry_run: Optional[bool] = Field(None, alias='dryRun')
    id: Optional[str] = None
    name: Optional[str] = None
    prune: Optional[bool] = None


class ApplicationApplicationSyncWindow(BaseModel):
    duration: Optional[str] = None
    kind: Optional[str] = None
    manual_sync: Optional[bool] = Field(None, alias='manualSync')
    schedule: Optional[str] = None


class ApplicationApplicationSyncWindowsResponse(BaseModel):
    active_windows: Optional[List[ApplicationApplicationSyncWindow]] = Field(None, alias='activeWindows')
    assigned_windows: Optional[List[ApplicationApplicationSyncWindow]] = Field(None, alias='assignedWindows')
    can_sync: Optional[bool] = Field(None, alias='canSync')


class ApplicationFileChunk(BaseModel):
    chunk: Optional[str] = None


class ApplicationLinkInfo(BaseModel):
    description: Optional[str] = None
    icon_class: Optional[str] = Field(None, alias='iconClass')
    title: Optional[str] = None
    url: Optional[str] = None


class ApplicationLinksResponse(BaseModel):
    items: Optional[List[ApplicationLinkInfo]] = None


class ApplicationOperationTerminateResponse(BaseModel):
    pass


class ApplicationSyncOptions(BaseModel):
    items: Optional[List[str]] = None


class Applicationv1alpha1EnvEntry(BaseModel):
    name: Optional[str] = Field(None, title='Name is the name of the variable, usually expressed in uppercase')
    value: Optional[str] = Field(None, title='Value is the value of the variable')


class ClusterClusterID(BaseModel):
    type: Optional[str] = Field(
        None, title='type is the type of the specified cluster identifier ( "server" - default, "name" )'
    )
    value: Optional[str] = Field(None, title='value holds the cluster server URL or cluster name')


class ClusterClusterResponse(BaseModel):
    pass


class ClusterConnector(BaseModel):
    name: Optional[str] = None
    type: Optional[str] = None


class ClusterDexConfig(BaseModel):
    connectors: Optional[List[ClusterConnector]] = None


class ClusterGoogleAnalyticsConfig(BaseModel):
    anonymize_users: Optional[bool] = Field(None, alias='anonymizeUsers')
    tracking_id: Optional[str] = Field(None, alias='trackingID')


class ClusterHelp(BaseModel):
    binary_urls: Optional[Dict[str, str]] = Field(
        None, alias='binaryUrls', title='the URLs for downloading argocd binaries'
    )
    chat_text: Optional[str] = Field(
        None, alias='chatText', title='the text for getting chat help, defaults to "Chat now!"'
    )
    chat_url: Optional[str] = Field(
        None,
        alias='chatUrl',
        title='the URL for getting chat help, this will typically be your Slack channel for support',
    )


class ClusterPlugin(BaseModel):
    name: Optional[str] = Field(None, title='the name of the plugin, e.g. "kasane"')


class ClusterSettingsPluginsResponse(BaseModel):
    plugins: Optional[List[ClusterPlugin]] = None


class GpgkeyGnuPGPublicKeyResponse(BaseModel):
    pass


class IntstrIntOrString(BaseModel):
    int_val: Optional[int] = Field(None, alias='intVal')
    str_val: Optional[str] = Field(None, alias='strVal')
    type: Optional[str] = None


class NotificationService(BaseModel):
    name: Optional[str] = None


class NotificationServiceList(BaseModel):
    items: Optional[List[NotificationService]] = None


class NotificationTemplate(BaseModel):
    name: Optional[str] = None


class NotificationTemplateList(BaseModel):
    items: Optional[List[NotificationTemplate]] = None


class NotificationTrigger(BaseModel):
    name: Optional[str] = None


class NotificationTriggerList(BaseModel):
    items: Optional[List[NotificationTrigger]] = None


class OidcClaim(BaseModel):
    essential: Optional[bool] = None
    value: Optional[str] = None
    values: Optional[List[str]] = None


class ProjectEmptyResponse(BaseModel):
    pass


class ProjectProjectTokenCreateRequest(BaseModel):
    description: Optional[str] = None
    expires_in: Optional[str] = Field(None, alias='expiresIn', title='expiresIn represents a duration in seconds')
    id: Optional[str] = None
    project: Optional[str] = None
    role: Optional[str] = None


class ProjectProjectTokenResponse(BaseModel):
    token: Optional[str] = None


class ProtobufAny(BaseModel):
    type_url: Optional[str] = None
    value: Optional[str] = None


class RepocredsRepoCredsResponse(BaseModel):
    pass


class RepositoryAppInfo(BaseModel):
    path: Optional[str] = None
    type: Optional[str] = None


class RepositoryDirectoryAppSpec(BaseModel):
    pass


class RepositoryHelmChart(BaseModel):
    name: Optional[str] = None
    versions: Optional[List[str]] = None


class RepositoryHelmChartsResponse(BaseModel):
    items: Optional[List[RepositoryHelmChart]] = None


class RepositoryKustomizeAppSpec(BaseModel):
    images: Optional[List[str]] = Field(None, description='images is a list of available images.')


class RepositoryManifestResponse(BaseModel):
    manifests: Optional[List[str]] = None
    namespace: Optional[str] = None
    revision: Optional[str] = Field(None, title='resolved revision')
    server: Optional[str] = None
    source_type: Optional[str] = Field(None, alias='sourceType')
    verify_result: Optional[str] = Field(
        None,
        alias='verifyResult',
        title='Raw response of git verify-commit operation (always the empty string for Helm)',
    )


class RepositoryParameterAnnouncement(BaseModel):
    array: Optional[List[str]] = Field(
        None, description='array is the default value of the parameter if the parameter is an array.'
    )
    collection_type: Optional[str] = Field(
        None,
        alias='collectionType',
        description=(
            'collectionType is the type of value this parameter holds - either a single value (a string) or a'
            ' collection\n(array or map). If collectionType is set, only the field with that type will be used. If'
            ' collectionType is not\nset, `string` is the default. If collectionType is set to an invalid value, a'
            ' validation error is thrown.'
        ),
    )
    item_type: Optional[str] = Field(
        None,
        alias='itemType',
        description=(
            'itemType determines the primitive data type represented by the parameter. Parameters are always encoded'
            ' as\nstrings, but this field lets them be interpreted as other primitive types.'
        ),
    )
    map: Optional[Dict[str, str]] = Field(
        None, description='map is the default value of the parameter if the parameter is a map.'
    )
    name: Optional[str] = Field(None, description='name is the name identifying a parameter.')
    required: Optional[bool] = Field(None, description='required defines if this given parameter is mandatory.')
    string: Optional[str] = Field(
        None, description='string is the default value of the parameter if the parameter is a string.'
    )
    title: Optional[str] = Field(None, description='title is a human-readable text of the parameter name.')
    tooltip: Optional[str] = Field(None, description='tooltip is a human-readable description of the parameter.')


class RepositoryPluginAppSpec(BaseModel):
    parameters_announcement: Optional[List[RepositoryParameterAnnouncement]] = Field(
        None, alias='parametersAnnouncement'
    )


class RepositoryRefs(BaseModel):
    branches: Optional[List[str]] = None
    tags: Optional[List[str]] = None


class RepositoryRepoAppsResponse(BaseModel):
    items: Optional[List[RepositoryAppInfo]] = None


class RepositoryRepoResponse(BaseModel):
    pass


class RuntimeError(BaseModel):
    code: Optional[int] = None
    details: Optional[List[ProtobufAny]] = None
    error: Optional[str] = None
    message: Optional[str] = None


class RuntimeStreamError(BaseModel):
    details: Optional[List[ProtobufAny]] = None
    grpc_code: Optional[int] = None
    http_code: Optional[int] = None
    http_status: Optional[str] = None
    message: Optional[str] = None


class SessionGetUserInfoResponse(BaseModel):
    groups: Optional[List[str]] = None
    iss: Optional[str] = None
    logged_in: Optional[bool] = Field(None, alias='loggedIn')
    username: Optional[str] = None


class SessionSessionCreateRequest(BaseModel):
    password: Optional[str] = None
    token: Optional[str] = None
    username: Optional[str] = None


class SessionSessionResponse(BaseModel):
    token: Optional[str] = None


class V1EventSource(BaseModel):
    component: Optional[str] = Field(None, title='Component from which the event is generated.\n+optional')
    host: Optional[str] = Field(None, title='Node name on which the event is generated.\n+optional')


class V1FieldsV1(BaseModel):
    raw: Optional[str] = Field(None, alias='Raw', description='Raw is the underlying serialization of this object.')


class V1GroupKind(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None


class V1JSON(BaseModel):
    raw: Optional[str] = None


class V1LabelSelectorRequirement(BaseModel):
    key: Optional[str] = Field(
        None, title='key is the label key that the selector applies to.\n+patchMergeKey=key\n+patchStrategy=merge'
    )
    operator: Optional[str] = Field(
        None,
        description=(
            "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and"
            " DoesNotExist."
        ),
    )
    values: Optional[List[str]] = Field(
        None,
        title=(
            'values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty.'
            ' If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced'
            ' during a strategic\nmerge patch.\n+optional'
        ),
    )


class V1ListMeta(BaseModel):
    continue_: Optional[str] = Field(
        None,
        alias='continue',
        description=(
            'continue may be set if the user set a limit on the number of items returned, and indicates that\nthe'
            ' server has more data available. The value is opaque and may be used to issue another request\nto the'
            ' endpoint that served this list to retrieve the next set of available objects. Continuing a\nconsistent'
            ' list may not be possible if the server configuration has changed or more than a few\nminutes have'
            ' passed. The resourceVersion field returned when using this continue value will be\nidentical to the'
            ' value in the first response, unless you have received this token from an error\nmessage.'
        ),
    )
    remaining_item_count: Optional[str] = Field(
        None,
        alias='remainingItemCount',
        title=(
            'remainingItemCount is the number of subsequent items in the list which are not included in this\nlist'
            ' response. If the list request contained label or field selectors, then the number of\nremaining items is'
            ' unknown and the field will be left unset and omitted during serialization.\nIf the list is complete'
            ' (either because it is not chunking or because this is the last chunk),\nthen there are no more remaining'
            ' items and this field will be left unset and omitted during\nserialization.\nServers older than v1.15 do'
            ' not set this field.\nThe intended use of the remainingItemCount is *estimating* the size of a'
            ' collection. Clients\nshould not rely on the remainingItemCount to be set or to be exact.\n+optional'
        ),
    )
    resource_version: Optional[str] = Field(
        None,
        alias='resourceVersion',
        title=(
            "String that identifies the server's internal version of this object that\ncan be used by clients to"
            " determine when objects have changed.\nValue must be treated as opaque by clients and passed unmodified"
            " back to the server.\nPopulated by the system.\nRead-only.\nMore info:"
            " https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional"
        ),
    )
    self_link: Optional[str] = Field(
        None,
        alias='selfLink',
        title='Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.\n+optional',
    )


class V1MicroTime(BaseModel):
    nanos: Optional[int] = Field(
        None,
        description=(
            'Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must'
            ' still have non-negative nanos values\nthat count forward in time. Must be from 0 to'
            ' 999,999,999\ninclusive. This field may be limited in precision depending on context.'
        ),
    )
    seconds: Optional[str] = Field(
        None,
        description=(
            'Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z'
            ' to\n9999-12-31T23:59:59Z inclusive.'
        ),
    )


class V1NodeSystemInfo(BaseModel):
    architecture: Optional[str] = Field(None, title='The Architecture reported by the node')
    boot_id: Optional[str] = Field(None, alias='bootID', description='Boot ID reported by the node.')
    container_runtime_version: Optional[str] = Field(
        None,
        alias='containerRuntimeVersion',
        description=(
            'ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).'
        ),
    )
    kernel_version: Optional[str] = Field(
        None,
        alias='kernelVersion',
        description="Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).",
    )
    kube_proxy_version: Optional[str] = Field(
        None, alias='kubeProxyVersion', description='KubeProxy Version reported by the node.'
    )
    kubelet_version: Optional[str] = Field(
        None, alias='kubeletVersion', description='Kubelet Version reported by the node.'
    )
    machine_id: Optional[str] = Field(
        None,
        alias='machineID',
        title=(
            'MachineID reported by the node. For unique machine identification\nin the cluster this field is'
            ' preferred. Learn more from man(5)\nmachine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html'
        ),
    )
    operating_system: Optional[str] = Field(
        None, alias='operatingSystem', title='The Operating System reported by the node'
    )
    os_image: Optional[str] = Field(
        None,
        alias='osImage',
        description='OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).',
    )
    system_uuid: Optional[str] = Field(
        None,
        alias='systemUUID',
        title=(
            'SystemUUID reported by the node. For unique machine identification\nMachineID is preferred. This field is'
            ' specific to Red Hat'
            ' hosts\nhttps://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid'
        ),
    )


class V1ObjectReference(BaseModel):
    api_version: Optional[str] = Field(None, alias='apiVersion', title='API version of the referent.\n+optional')
    field_path: Optional[str] = Field(
        None,
        alias='fieldPath',
        title=(
            'If referring to a piece of an object instead of an entire object, this string\nshould contain a valid'
            ' JSON/Go field access statement, such as desiredState.manifest.containers[2].\nFor example, if the object'
            ' reference is to a container within a pod, this would take on a value like:\n"spec.containers{name}"'
            ' (where "name" refers to the name of the container that triggered\nthe event) or if no container name is'
            ' specified "spec.containers[2]" (container with\nindex 2 in this pod). This syntax is chosen only to have'
            ' some well-defined way of\nreferencing a part of an object.\nTODO: this design is not final and this'
            ' field is subject to change in the future.\n+optional'
        ),
    )
    kind: Optional[str] = Field(
        None,
        title=(
            'Kind of the referent.\nMore info:'
            ' https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional'
        ),
    )
    name: Optional[str] = Field(
        None,
        title=(
            'Name of the referent.\nMore info:'
            ' https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n+optional'
        ),
    )
    namespace: Optional[str] = Field(
        None,
        title=(
            'Namespace of the referent.\nMore info:'
            ' https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\n+optional'
        ),
    )
    resource_version: Optional[str] = Field(
        None,
        alias='resourceVersion',
        title=(
            'Specific resourceVersion to which this reference is made, if any.\nMore info:'
            ' https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional'
        ),
    )
    uid: Optional[str] = Field(
        None,
        title=(
            'UID of the referent.\nMore info:'
            ' https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids\n+optional'
        ),
    )


class V1OwnerReference(BaseModel):
    api_version: Optional[str] = Field(None, alias='apiVersion', description='API version of the referent.')
    block_owner_deletion: Optional[bool] = Field(
        None,
        alias='blockOwnerDeletion',
        title=(
            'If true, AND if the owner has the "foregroundDeletion" finalizer, then\nthe owner cannot be deleted from'
            ' the key-value store until this\nreference is removed.\nSee'
            ' https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion\nfor how the'
            ' garbage collector interacts with this field and enforces the foreground deletion.\nDefaults to'
            ' false.\nTo set this field, a user needs "delete" permission of the owner,\notherwise 422 (Unprocessable'
            ' Entity) will be returned.\n+optional'
        ),
    )
    controller: Optional[bool] = Field(
        None, title='If true, this reference points to the managing controller.\n+optional'
    )
    kind: Optional[str] = Field(
        None,
        title=(
            'Kind of the referent.\nMore info:'
            ' https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
        ),
    )
    name: Optional[str] = Field(
        None, title='Name of the referent.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#names'
    )
    uid: Optional[str] = Field(
        None, title='UID of the referent.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#uids'
    )


class V1PortStatus(BaseModel):
    error: Optional[str] = Field(
        None,
        title=(
            'Error is to record the problem with the service port\nThe format of the error shall comply with the'
            ' following rules:\n- built-in error values shall be specified in this file and those shall use\n '
            ' CamelCase names\n- cloud provider specific error values must have names that comply with the\n  format'
            ' foo.example.com/CamelCase.\n---\nThe regex it matches is'
            ' (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n+optional\n+kubebuilder:validation:Required\n+kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`\n+kubebuilder:validation:MaxLength=316'
        ),
    )
    port: Optional[int] = Field(
        None, title='Port is the port number of the service port of which status is recorded here'
    )
    protocol: Optional[str] = Field(
        None,
        title=(
            'Protocol is the protocol of the service port of which status is recorded here\nThe supported values are:'
            ' "TCP", "UDP", "SCTP"'
        ),
    )


class V1Time(BaseModel):
    nanos: Optional[int] = Field(
        None,
        description=(
            'Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must'
            ' still have non-negative nanos values\nthat count forward in time. Must be from 0 to'
            ' 999,999,999\ninclusive. This field may be limited in precision depending on context.'
        ),
    )
    seconds: Optional[str] = Field(
        None,
        description=(
            'Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z'
            ' to\n9999-12-31T23:59:59Z inclusive.'
        ),
    )


class V1alpha1AWSAuthConfig(BaseModel):
    cluster_name: Optional[str] = Field(None, alias='clusterName', title='ClusterName contains AWS cluster name')
    role_arn: Optional[str] = Field(
        None,
        alias='roleARN',
        description=(
            'RoleARN contains optional role ARN. If set then AWS IAM Authenticator assume a role to perform cluster'
            ' operations instead of the default AWS credential provider chain.'
        ),
    )


class V1alpha1ApplicationCondition(BaseModel):
    last_transition_time: Optional[V1Time] = Field(None, alias='lastTransitionTime')
    message: Optional[str] = Field(
        None, title='Message contains human-readable message indicating details about condition'
    )
    type: Optional[str] = Field(None, title='Type is an application condition type')


class V1alpha1ApplicationDestination(BaseModel):
    name: Optional[str] = Field(
        None, title='Name is an alternate way of specifying the target cluster by its symbolic name'
    )
    namespace: Optional[str] = Field(
        None,
        title=(
            "Namespace specifies the target namespace for the application's resources.\nThe namespace will only be set"
            " for namespace-scoped resources that have not set a value for .metadata.namespace"
        ),
    )
    server: Optional[str] = Field(
        None,
        title='Server specifies the URL of the target cluster and must be set to the Kubernetes control plane API',
    )


class V1alpha1ApplicationMatchExpression(BaseModel):
    key: Optional[str] = None
    operator: Optional[str] = None
    values: Optional[List[str]] = None


class V1alpha1ApplicationPreservedFields(BaseModel):
    annotations: Optional[List[str]] = None


class V1alpha1ApplicationSetApplicationStatus(BaseModel):
    application: Optional[str] = Field(None, title='Application contains the name of the Application resource')
    last_transition_time: Optional[V1Time] = Field(None, alias='lastTransitionTime')
    message: Optional[str] = Field(
        None, title='Message contains human-readable message indicating details about the status'
    )
    status: Optional[str] = Field(
        None,
        title=(
            "Status contains the AppSet's perceived status of the managed Application resource: (Waiting, Pending,"
            " Progressing, Healthy)"
        ),
    )
    step: Optional[str] = Field(None, title='Step tracks which step this Application should be updated in')


class V1alpha1ApplicationSetCondition(BaseModel):
    last_transition_time: Optional[V1Time] = Field(None, alias='lastTransitionTime')
    message: Optional[str] = Field(
        None, title='Message contains human-readable message indicating details about condition'
    )
    reason: Optional[str] = Field(
        None, title='Single word camelcase representing the reason for the status eg ErrorOccurred'
    )
    status: Optional[str] = Field(None, title='True/False/Unknown')
    type: Optional[str] = Field(None, title='Type is an applicationset condition type')


class V1alpha1ApplicationSetRolloutStep(BaseModel):
    match_expressions: Optional[List[V1alpha1ApplicationMatchExpression]] = Field(None, alias='matchExpressions')
    max_update: Optional[IntstrIntOrString] = Field(None, alias='maxUpdate')


class V1alpha1ApplicationSetRolloutStrategy(BaseModel):
    steps: Optional[List[V1alpha1ApplicationSetRolloutStep]] = None


class V1alpha1ApplicationSetStatus(BaseModel):
    application_status: Optional[List[V1alpha1ApplicationSetApplicationStatus]] = Field(
        None, alias='applicationStatus'
    )
    conditions: Optional[List[V1alpha1ApplicationSetCondition]] = Field(
        None,
        title=(
            'INSERT ADDITIONAL STATUS FIELD - define observed state of cluster\nImportant: Run "make" to regenerate'
            ' code after modifying this file'
        ),
    )


class V1alpha1ApplicationSetStrategy(BaseModel):
    rolling_sync: Optional[V1alpha1ApplicationSetRolloutStrategy] = Field(None, alias='rollingSync')
    type: Optional[str] = None


class V1alpha1ApplicationSetSyncPolicy(BaseModel):
    preserve_resources_on_deletion: Optional[bool] = Field(
        None,
        alias='preserveResourcesOnDeletion',
        description=(
            'PreserveResourcesOnDeletion will preserve resources on deletion. If PreserveResourcesOnDeletion is set to'
            ' true, these Applications will not be deleted.'
        ),
    )


class V1alpha1ApplicationSetTemplateMeta(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    finalizers: Optional[List[str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None


class V1alpha1ApplicationSourcePluginParameter(BaseModel):
    array: Optional[List[str]] = Field(None, description='Array is the value of an array type parameter.')
    map: Optional[Dict[str, str]] = Field(None, description='Map is the value of a map type parameter.')
    name: Optional[str] = Field(None, description='Name is the name identifying a parameter.')
    string: Optional[str] = Field(None, description='String_ is the value of a string type parameter.')


class V1alpha1ApplicationSummary(BaseModel):
    external_ur_ls: Optional[List[str]] = Field(
        None, alias='externalURLs', description='ExternalURLs holds all external URLs of application child resources.'
    )
    images: Optional[List[str]] = Field(None, description='Images holds all images of application child resources.')


class V1alpha1Backoff(BaseModel):
    duration: Optional[str] = Field(
        None,
        title=(
            'Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m",'
            ' "1h")'
        ),
    )
    factor: Optional[str] = Field(
        None, title='Factor is a factor to multiply the base duration after each failed retry'
    )
    max_duration: Optional[str] = Field(
        None, alias='maxDuration', title='MaxDuration is the maximum amount of time allowed for the backoff strategy'
    )


class V1alpha1ChartDetails(BaseModel):
    description: Optional[str] = None
    home: Optional[str] = Field(None, title='The URL of this projects home page, e.g. "http://example.com"')
    maintainers: Optional[List[str]] = Field(
        None, title='List of maintainer details, name and email, e.g. ["John Doe <john_doe@my-company.com>"]'
    )


class V1alpha1ClusterCacheInfo(BaseModel):
    apis_count: Optional[str] = Field(
        None, alias='apisCount', title='APIsCount holds number of observed Kubernetes API count'
    )
    last_cache_sync_time: Optional[V1Time] = Field(None, alias='lastCacheSyncTime')
    resources_count: Optional[str] = Field(
        None, alias='resourcesCount', title='ResourcesCount holds number of observed Kubernetes resources'
    )


class V1alpha1Command(BaseModel):
    args: Optional[List[str]] = None
    command: Optional[List[str]] = None


class V1alpha1ConfigManagementPlugin(BaseModel):
    generate: Optional[V1alpha1Command] = None
    init: Optional[V1alpha1Command] = None
    lock_repo: Optional[bool] = Field(None, alias='lockRepo')
    name: Optional[str] = None


class V1alpha1ConnectionState(BaseModel):
    attempted_at: Optional[V1Time] = Field(None, alias='attemptedAt')
    message: Optional[str] = Field(
        None, title='Message contains human readable information about the connection status'
    )
    status: Optional[str] = Field(None, title='Status contains the current status indicator for the connection')


class V1alpha1ExecProviderConfig(BaseModel):
    api_version: Optional[str] = Field(None, alias='apiVersion', title='Preferred input version of the ExecInfo')
    args: Optional[List[str]] = Field(None, title='Arguments to pass to the command when executing it')
    command: Optional[str] = Field(None, title='Command to execute')
    env: Optional[Dict[str, str]] = Field(
        None, title='Env defines additional environment variables to expose to the process'
    )
    install_hint: Optional[str] = Field(
        None,
        alias='installHint',
        title="This text is shown to the user when the executable doesn't seem to be present",
    )


class V1alpha1GitDirectoryGeneratorItem(BaseModel):
    exclude: Optional[bool] = None
    path: Optional[str] = None


class V1alpha1GitFileGeneratorItem(BaseModel):
    path: Optional[str] = None


class V1alpha1GnuPGPublicKey(BaseModel):
    fingerprint: Optional[str] = Field(None, title='Fingerprint is the fingerprint of the key')
    key_data: Optional[str] = Field(
        None, alias='keyData', title='KeyData holds the raw key data, in base64 encoded format'
    )
    key_id: Optional[str] = Field(
        None, alias='keyID', title='KeyID specifies the key ID, in hexadecimal string format'
    )
    owner: Optional[str] = Field(None, title='Owner holds the owner identification, e.g. a name and e-mail address')
    sub_type: Optional[str] = Field(None, alias='subType', title="SubType holds the key's sub type (e.g. rsa4096)")
    trust: Optional[str] = Field(None, title='Trust holds the level of trust assigned to this key')


class V1alpha1GnuPGPublicKeyList(BaseModel):
    items: Optional[List[V1alpha1GnuPGPublicKey]] = None
    metadata: Optional[V1ListMeta] = None


class V1alpha1HealthStatus(BaseModel):
    message: Optional[str] = Field(
        None, title='Message is a human-readable informational message describing the health status'
    )
    status: Optional[str] = Field(None, title='Status holds the status code of the application or resource')


class V1alpha1HelmFileParameter(BaseModel):
    name: Optional[str] = Field(None, title='Name is the name of the Helm parameter')
    path: Optional[str] = Field(
        None, title='Path is the path to the file containing the values for the Helm parameter'
    )


class V1alpha1HelmParameter(BaseModel):
    force_string: Optional[bool] = Field(
        None,
        alias='forceString',
        title='ForceString determines whether to tell Helm to interpret booleans and numbers as strings',
    )
    name: Optional[str] = Field(None, title='Name is the name of the Helm parameter')
    value: Optional[str] = Field(None, title='Value is the value for the Helm parameter')


class V1alpha1HostResourceInfo(BaseModel):
    capacity: Optional[str] = None
    requested_by_app: Optional[str] = Field(None, alias='requestedByApp')
    requested_by_neighbors: Optional[str] = Field(None, alias='requestedByNeighbors')
    resource_name: Optional[str] = Field(None, alias='resourceName')


class V1alpha1Info(BaseModel):
    name: Optional[str] = None
    value: Optional[str] = None


class V1alpha1InfoItem(BaseModel):
    name: Optional[str] = Field(None, description='Name is a human readable title for this piece of information.')
    value: Optional[str] = Field(None, description='Value is human readable content.')


class V1alpha1JWTToken(BaseModel):
    exp: Optional[str] = None
    iat: Optional[str] = None
    id: Optional[str] = None


class V1alpha1JWTTokens(BaseModel):
    items: Optional[List[V1alpha1JWTToken]] = None


class V1alpha1JsonnetVar(BaseModel):
    code: Optional[bool] = None
    name: Optional[str] = None
    value: Optional[str] = None


class V1alpha1KnownTypeField(BaseModel):
    field: Optional[str] = None
    type: Optional[str] = None


class V1alpha1KustomizeOptions(BaseModel):
    binary_path: Optional[str] = Field(
        None, alias='binaryPath', title='BinaryPath holds optional path to kustomize binary'
    )
    build_options: Optional[str] = Field(
        None,
        alias='buildOptions',
        title='BuildOptions is a string of build parameters to use when calling `kustomize build`',
    )


class V1alpha1KustomizeReplica(BaseModel):
    count: Optional[IntstrIntOrString] = None
    name: Optional[str] = Field(None, title='Name of Deployment or StatefulSet')


class V1alpha1ManagedNamespaceMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None


class V1alpha1OperationInitiator(BaseModel):
    automated: Optional[bool] = Field(
        None,
        description='Automated is set to true if operation was initiated automatically by the application controller.',
    )
    username: Optional[str] = Field(None, title='Username contains the name of a user who started operation')


class V1alpha1OrphanedResourceKey(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None


class V1alpha1OrphanedResourcesMonitorSettings(BaseModel):
    ignore: Optional[List[V1alpha1OrphanedResourceKey]] = Field(
        None, title='Ignore contains a list of resources that are to be excluded from orphaned resources monitoring'
    )
    warn: Optional[bool] = Field(
        None, title='Warn indicates if warning condition should be created for apps which have orphaned resources'
    )


class V1alpha1OverrideIgnoreDiff(BaseModel):
    j_son_pointers: Optional[List[str]] = Field(
        None,
        alias='jSONPointers',
        title=(
            'JSONPointers is a JSON path list following the format defined in RFC4627'
            ' (https://datatracker.ietf.org/doc/html/rfc6902#section-3)'
        ),
    )
    jq_path_expressions: Optional[List[str]] = Field(
        None,
        alias='jqPathExpressions',
        title='JQPathExpressions is a JQ path list that will be evaludated during the diff process',
    )
    managed_fields_managers: Optional[List[str]] = Field(
        None,
        alias='managedFieldsManagers',
        title=(
            "ManagedFieldsManagers is a list of trusted managers. Fields mutated by those managers will take"
            " precedence over the\ndesired state defined in the SCM and won't be displayed in diffs"
        ),
    )


class V1alpha1ProjectRole(BaseModel):
    description: Optional[str] = Field(None, title='Description is a description of the role')
    groups: Optional[List[str]] = Field(None, title='Groups are a list of OIDC group claims bound to this role')
    jwt_tokens: Optional[List[V1alpha1JWTToken]] = Field(
        None, alias='jwtTokens', title='JWTTokens are a list of generated JWT tokens bound to this role'
    )
    name: Optional[str] = Field(None, title='Name is a name for this role')
    policies: Optional[List[str]] = Field(
        None,
        title=(
            'Policies Stores a list of casbin formatted strings that define access policies for the role in the'
            ' project'
        ),
    )


class V1alpha1PullRequestGeneratorFilter(BaseModel):
    branch_match: Optional[str] = Field(None, alias='branchMatch')


class V1alpha1RepoCreds(BaseModel):
    enable_oci: Optional[bool] = Field(
        None, alias='enableOCI', title='EnableOCI specifies whether helm-oci support should be enabled for this repo'
    )
    force_http_basic_auth: Optional[bool] = Field(
        None,
        alias='forceHttpBasicAuth',
        title='ForceHttpBasicAuth specifies whether Argo CD should attempt to force basic auth for HTTP connections',
    )
    gcp_service_account_key: Optional[str] = Field(
        None,
        alias='gcpServiceAccountKey',
        title=(
            'GCPServiceAccountKey specifies the service account key in JSON format to be used for getting credentials'
            ' to Google Cloud Source repos'
        ),
    )
    github_app_enterprise_base_url: Optional[str] = Field(
        None,
        alias='githubAppEnterpriseBaseUrl',
        title=(
            'GithubAppEnterpriseBaseURL specifies the GitHub API URL for GitHub app authentication. If empty will'
            ' default to https://api.github.com'
        ),
    )
    github_app_id: Optional[str] = Field(
        None,
        alias='githubAppID',
        title=(
            'GithubAppId specifies the Github App ID of the app used to access the repo for GitHub app authentication'
        ),
    )
    github_app_installation_id: Optional[str] = Field(
        None,
        alias='githubAppInstallationID',
        title='GithubAppInstallationId specifies the ID of the installed GitHub App for GitHub app authentication',
    )
    github_app_private_key: Optional[str] = Field(
        None,
        alias='githubAppPrivateKey',
        title='GithubAppPrivateKey specifies the private key PEM data for authentication via GitHub app',
    )
    password: Optional[str] = Field(None, title='Password for authenticating at the repo server')
    proxy: Optional[str] = Field(
        None, title='Proxy specifies the HTTP/HTTPS proxy used to access repos at the repo server'
    )
    ssh_private_key: Optional[str] = Field(
        None,
        alias='sshPrivateKey',
        title=(
            'SSHPrivateKey contains the private key data for authenticating at the repo server using SSH (only Git'
            ' repos)'
        ),
    )
    tls_client_cert_data: Optional[str] = Field(
        None,
        alias='tlsClientCertData',
        title='TLSClientCertData specifies the TLS client cert data for authenticating at the repo server',
    )
    tls_client_cert_key: Optional[str] = Field(
        None,
        alias='tlsClientCertKey',
        title='TLSClientCertKey specifies the TLS client cert key for authenticating at the repo server',
    )
    type: Optional[str] = Field(
        None,
        description=(
            'Type specifies the type of the repoCreds. Can be either "git" or "helm. "git" is assumed if empty or'
            ' absent.'
        ),
    )
    url: Optional[str] = Field(None, title='URL is the URL that this credentials matches to')
    username: Optional[str] = Field(None, title='Username for authenticating at the repo server')


class V1alpha1RepoCredsList(BaseModel):
    items: Optional[List[V1alpha1RepoCreds]] = None
    metadata: Optional[V1ListMeta] = None


class V1alpha1Repository(BaseModel):
    connection_state: Optional[V1alpha1ConnectionState] = Field(None, alias='connectionState')
    enable_lfs: Optional[bool] = Field(
        None,
        alias='enableLfs',
        description=(
            'EnableLFS specifies whether git-lfs support should be enabled for this repo. Only valid for Git'
            ' repositories.'
        ),
    )
    enable_oci: Optional[bool] = Field(
        None, alias='enableOCI', title='EnableOCI specifies whether helm-oci support should be enabled for this repo'
    )
    force_http_basic_auth: Optional[bool] = Field(
        None,
        alias='forceHttpBasicAuth',
        title='ForceHttpBasicAuth specifies whether Argo CD should attempt to force basic auth for HTTP connections',
    )
    gcp_service_account_key: Optional[str] = Field(
        None,
        alias='gcpServiceAccountKey',
        title=(
            'GCPServiceAccountKey specifies the service account key in JSON format to be used for getting credentials'
            ' to Google Cloud Source repos'
        ),
    )
    github_app_enterprise_base_url: Optional[str] = Field(
        None,
        alias='githubAppEnterpriseBaseUrl',
        title=(
            'GithubAppEnterpriseBaseURL specifies the base URL of GitHub Enterprise installation. If empty will'
            ' default to https://api.github.com'
        ),
    )
    github_app_id: Optional[str] = Field(
        None, alias='githubAppID', title='GithubAppId specifies the ID of the GitHub app used to access the repo'
    )
    github_app_installation_id: Optional[str] = Field(
        None,
        alias='githubAppInstallationID',
        title='GithubAppInstallationId specifies the installation ID of the GitHub App used to access the repo',
    )
    github_app_private_key: Optional[str] = Field(
        None, alias='githubAppPrivateKey', title='Github App Private Key PEM data'
    )
    inherited_creds: Optional[bool] = Field(
        None, alias='inheritedCreds', title='Whether credentials were inherited from a credential set'
    )
    insecure: Optional[bool] = Field(
        None,
        title=(
            'Insecure specifies whether the connection to the repository ignores any errors when verifying TLS'
            ' certificates or SSH host keys'
        ),
    )
    insecure_ignore_host_key: Optional[bool] = Field(
        None,
        alias='insecureIgnoreHostKey',
        title='InsecureIgnoreHostKey should not be used anymore, Insecure is favoured\nUsed only for Git repos',
    )
    name: Optional[str] = Field(
        None, title='Name specifies a name to be used for this repo. Only used with Helm repos'
    )
    password: Optional[str] = Field(
        None, title='Password contains the password or PAT used for authenticating at the remote repository'
    )
    project: Optional[str] = Field(
        None,
        title=(
            'Reference between project and repository that allow you automatically to be added as item inside'
            ' SourceRepos project entity'
        ),
    )
    proxy: Optional[str] = Field(None, title='Proxy specifies the HTTP/HTTPS proxy used to access the repo')
    repo: Optional[str] = Field(None, title='Repo contains the URL to the remote repository')
    ssh_private_key: Optional[str] = Field(
        None,
        alias='sshPrivateKey',
        description=(
            'SSHPrivateKey contains the PEM data for authenticating at the repo server. Only used with Git repos.'
        ),
    )
    tls_client_cert_data: Optional[str] = Field(
        None,
        alias='tlsClientCertData',
        title='TLSClientCertData contains a certificate in PEM format for authenticating at the repo server',
    )
    tls_client_cert_key: Optional[str] = Field(
        None,
        alias='tlsClientCertKey',
        title='TLSClientCertKey contains a private key in PEM format for authenticating at the repo server',
    )
    type: Optional[str] = Field(
        None,
        description=(
            'Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.'
        ),
    )
    username: Optional[str] = Field(
        None, title='Username contains the user name used for authenticating at the remote repository'
    )


class V1alpha1RepositoryCertificate(BaseModel):
    cert_data: Optional[str] = Field(
        None,
        alias='certData',
        title='CertData contains the actual certificate data, dependent on the certificate type',
    )
    cert_info: Optional[str] = Field(
        None,
        alias='certInfo',
        title=(
            'CertInfo will hold additional certificate info, depdendent on the certificate type (e.g. SSH fingerprint,'
            ' X509 CommonName)'
        ),
    )
    cert_sub_type: Optional[str] = Field(
        None, alias='certSubType', title='CertSubType specifies the sub type of the cert, i.e. "ssh-rsa"'
    )
    cert_type: Optional[str] = Field(
        None,
        alias='certType',
        title='CertType specifies the type of the certificate - currently one of "https" or "ssh"',
    )
    server_name: Optional[str] = Field(
        None,
        alias='serverName',
        title='ServerName specifies the DNS name of the server this certificate is intended for',
    )


class V1alpha1RepositoryCertificateList(BaseModel):
    items: Optional[List[V1alpha1RepositoryCertificate]] = Field(None, title='List of certificates to be processed')
    metadata: Optional[V1ListMeta] = None


class V1alpha1RepositoryList(BaseModel):
    items: Optional[List[V1alpha1Repository]] = None
    metadata: Optional[V1ListMeta] = None


class V1alpha1ResourceActionParam(BaseModel):
    default: Optional[str] = None
    name: Optional[str] = None
    type: Optional[str] = None
    value: Optional[str] = None


class V1alpha1ResourceDiff(BaseModel):
    diff: Optional[str] = Field(
        None,
        title=(
            'Diff contains the JSON patch between target and live resource\nDeprecated: use NormalizedLiveState and'
            ' PredictedLiveState to render the difference'
        ),
    )
    group: Optional[str] = None
    hook: Optional[bool] = None
    kind: Optional[str] = None
    live_state: Optional[str] = Field(
        None, alias='liveState', title='TargetState contains the JSON live resource manifest'
    )
    modified: Optional[bool] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    normalized_live_state: Optional[str] = Field(
        None,
        alias='normalizedLiveState',
        title='NormalizedLiveState contains JSON serialized live resource state with applied normalizations',
    )
    predicted_live_state: Optional[str] = Field(
        None,
        alias='predictedLiveState',
        title=(
            'PredictedLiveState contains JSON serialized resource state that is calculated based on normalized and'
            ' target resource state'
        ),
    )
    resource_version: Optional[str] = Field(None, alias='resourceVersion')
    target_state: Optional[str] = Field(
        None,
        alias='targetState',
        title='TargetState contains the JSON serialized resource manifest defined in the Git/Helm',
    )


class V1alpha1ResourceIgnoreDifferences(BaseModel):
    group: Optional[str] = None
    jq_path_expressions: Optional[List[str]] = Field(None, alias='jqPathExpressions')
    json_pointers: Optional[List[str]] = Field(None, alias='jsonPointers')
    kind: Optional[str] = None
    managed_fields_managers: Optional[List[str]] = Field(
        None,
        alias='managedFieldsManagers',
        title=(
            "ManagedFieldsManagers is a list of trusted managers. Fields mutated by those managers will take"
            " precedence over the\ndesired state defined in the SCM and won't be displayed in diffs"
        ),
    )
    name: Optional[str] = None
    namespace: Optional[str] = None


class V1alpha1ResourceOverride(BaseModel):
    actions: Optional[str] = None
    health_lua: Optional[str] = Field(None, alias='healthLua')
    ignore_differences: Optional[V1alpha1OverrideIgnoreDiff] = Field(None, alias='ignoreDifferences')
    known_type_fields: Optional[List[V1alpha1KnownTypeField]] = Field(None, alias='knownTypeFields')
    use_open_libs: Optional[bool] = Field(None, alias='useOpenLibs')


class V1alpha1ResourceRef(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    uid: Optional[str] = None
    version: Optional[str] = None


class V1alpha1ResourceResult(BaseModel):
    group: Optional[str] = Field(None, title='Group specifies the API group of the resource')
    hook_phase: Optional[str] = Field(
        None,
        alias='hookPhase',
        description=(
            'HookPhase contains the state of any operation associated with this resource OR hook\nThis can also'
            ' contain values for non-hook resources.'
        ),
    )
    hook_type: Optional[str] = Field(
        None, alias='hookType', title='HookType specifies the type of the hook. Empty for non-hook resources'
    )
    kind: Optional[str] = Field(None, title='Kind specifies the API kind of the resource')
    message: Optional[str] = Field(
        None, title='Message contains an informational or error message for the last sync OR operation'
    )
    name: Optional[str] = Field(None, title='Name specifies the name of the resource')
    namespace: Optional[str] = Field(None, title='Namespace specifies the target namespace of the resource')
    status: Optional[str] = Field(
        None,
        title=(
            'Status holds the final result of the sync. Will be empty if the resources is yet to be applied/pruned and'
            ' is always zero-value for hooks'
        ),
    )
    sync_phase: Optional[str] = Field(
        None,
        alias='syncPhase',
        title='SyncPhase indicates the particular phase of the sync that this result was acquired in',
    )
    version: Optional[str] = Field(None, title='Version specifies the API version of the resource')


class V1alpha1ResourceStatus(BaseModel):
    group: Optional[str] = None
    health: Optional[V1alpha1HealthStatus] = None
    hook: Optional[bool] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    requires_pruning: Optional[bool] = Field(None, alias='requiresPruning')
    status: Optional[str] = None
    sync_wave: Optional[str] = Field(None, alias='syncWave')
    version: Optional[str] = None


class V1alpha1RetryStrategy(BaseModel):
    backoff: Optional[V1alpha1Backoff] = None
    limit: Optional[str] = Field(
        None,
        description=(
            'Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be'
            ' performed.'
        ),
    )


class V1alpha1RevisionMetadata(BaseModel):
    author: Optional[str] = Field(
        None,
        title=(
            'who authored this revision,\ntypically their name and email, e.g. "John Doe'
            ' <john_doe@my-company.com>",\nbut might not match this example'
        ),
    )
    date: Optional[V1Time] = None
    message: Optional[str] = Field(
        None, description='Message contains the message associated with the revision, most likely the commit message.'
    )
    signature_info: Optional[str] = Field(
        None,
        alias='signatureInfo',
        description=(
            'SignatureInfo contains a hint on the signer if the revision was signed with GPG, and signature'
            ' verification is enabled.'
        ),
    )
    tags: Optional[List[str]] = Field(
        None,
        title=(
            'Tags specifies any tags currently attached to the revision\nFloating tags can move from one revision to'
            ' another'
        ),
    )


class V1alpha1SCMProviderGeneratorFilter(BaseModel):
    branch_match: Optional[str] = Field(
        None, alias='branchMatch', description='A regex which must match the branch name.'
    )
    label_match: Optional[str] = Field(
        None, alias='labelMatch', description='A regex which must match at least one label.'
    )
    paths_do_not_exist: Optional[List[str]] = Field(
        None, alias='pathsDoNotExist', description='An array of paths, all of which must not exist.'
    )
    paths_exist: Optional[List[str]] = Field(
        None, alias='pathsExist', description='An array of paths, all of which must exist.'
    )
    repository_match: Optional[str] = Field(None, alias='repositoryMatch', description='A regex for repo names.')


class V1alpha1SecretRef(BaseModel):
    key: Optional[str] = None
    secret_name: Optional[str] = Field(None, alias='secretName')


class V1alpha1SignatureKey(BaseModel):
    key_id: Optional[str] = Field(None, alias='keyID', title='The ID of the key in hexadecimal notation')


class V1alpha1SyncOperationResource(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None


class V1alpha1SyncPolicyAutomated(BaseModel):
    allow_empty: Optional[bool] = Field(
        None, alias='allowEmpty', title='AllowEmpty allows apps have zero live resources (default: false)'
    )
    prune: Optional[bool] = Field(
        None,
        title=(
            'Prune specifies whether to delete resources from the cluster that are not found in the sources anymore as'
            ' part of automated sync (default: false)'
        ),
    )
    self_heal: Optional[bool] = Field(
        None,
        alias='selfHeal',
        title=(
            'SelfHeal specifes whether to revert resources back to their desired state upon modification in the'
            ' cluster (default: false)'
        ),
    )


class V1alpha1SyncStrategyApply(BaseModel):
    force: Optional[bool] = Field(
        None,
        description=(
            'Force indicates whether or not to supply the --force flag to `kubectl apply`.\nThe --force flag deletes'
            ' and re-create the resource, when PATCH encounters conflict and has\nretried for 5 times.'
        ),
    )


class V1alpha1SyncStrategyHook(BaseModel):
    sync_strategy_apply: Optional[V1alpha1SyncStrategyApply] = Field(None, alias='syncStrategyApply')


class V1alpha1SyncWindow(BaseModel):
    applications: Optional[List[str]] = Field(
        None, title='Applications contains a list of applications that the window will apply to'
    )
    clusters: Optional[List[str]] = Field(
        None, title='Clusters contains a list of clusters that the window will apply to'
    )
    duration: Optional[str] = Field(None, title='Duration is the amount of time the sync window will be open')
    kind: Optional[str] = Field(None, title='Kind defines if the window allows or blocks syncs')
    manual_sync: Optional[bool] = Field(
        None, alias='manualSync', title='ManualSync enables manual syncs when they would otherwise be blocked'
    )
    namespaces: Optional[List[str]] = Field(
        None, title='Namespaces contains a list of namespaces that the window will apply to'
    )
    schedule: Optional[str] = Field(None, title='Schedule is the time the window will begin, specified in cron format')
    time_zone: Optional[str] = Field(
        None, alias='timeZone', title='TimeZone of the sync that will be applied to the schedule'
    )


class V1alpha1TLSClientConfig(BaseModel):
    ca_data: Optional[str] = Field(
        None,
        alias='caData',
        title=(
            'CAData holds PEM-encoded bytes (typically read from a root certificates bundle).\nCAData takes precedence'
            ' over CAFile'
        ),
    )
    cert_data: Optional[str] = Field(
        None,
        alias='certData',
        title=(
            'CertData holds PEM-encoded bytes (typically read from a client certificate file).\nCertData takes'
            ' precedence over CertFile'
        ),
    )
    insecure: Optional[bool] = Field(
        None,
        description=(
            'Insecure specifies that the server should be accessed without verifying the TLS certificate. For testing'
            ' only.'
        ),
    )
    key_data: Optional[str] = Field(
        None,
        alias='keyData',
        title=(
            'KeyData holds PEM-encoded bytes (typically read from a client certificate key file).\nKeyData takes'
            ' precedence over KeyFile'
        ),
    )
    server_name: Optional[str] = Field(
        None,
        alias='serverName',
        description=(
            'ServerName is passed to the server for SNI and is used in the client to check server\ncertificates'
            ' against. If ServerName is empty, the hostname used to contact the\nserver is used.'
        ),
    )


class VersionVersionMessage(BaseModel):
    build_date: Optional[str] = Field(None, alias='BuildDate')
    compiler: Optional[str] = Field(None, alias='Compiler')
    git_commit: Optional[str] = Field(None, alias='GitCommit')
    git_tag: Optional[str] = Field(None, alias='GitTag')
    git_tree_state: Optional[str] = Field(None, alias='GitTreeState')
    go_version: Optional[str] = Field(None, alias='GoVersion')
    helm_version: Optional[str] = Field(None, alias='HelmVersion')
    jsonnet_version: Optional[str] = Field(None, alias='JsonnetVersion')
    kubectl_version: Optional[str] = Field(None, alias='KubectlVersion')
    kustomize_version: Optional[str] = Field(None, alias='KustomizeVersion')
    platform: Optional[str] = Field(None, alias='Platform')
    version: Optional[str] = Field(None, alias='Version')


class AccountAccount(BaseModel):
    capabilities: Optional[List[str]] = None
    enabled: Optional[bool] = None
    name: Optional[str] = None
    tokens: Optional[List[AccountToken]] = None


class AccountAccountsList(BaseModel):
    items: Optional[List[AccountAccount]] = None


class ApplicationApplicationManifestQueryWithFilesWrapper(BaseModel):
    chunk: Optional[ApplicationFileChunk] = None
    query: Optional[ApplicationApplicationManifestQueryWithFiles] = None


class ApplicationLogEntry(BaseModel):
    content: Optional[str] = None
    last: Optional[bool] = None
    pod_name: Optional[str] = Field(None, alias='podName')
    time_stamp: Optional[V1Time] = Field(None, alias='timeStamp')
    time_stamp_str: Optional[str] = Field(None, alias='timeStampStr')


class ApplicationManagedResourcesResponse(BaseModel):
    items: Optional[List[V1alpha1ResourceDiff]] = None


class ClusterOIDCConfig(BaseModel):
    cli_client_id: Optional[str] = Field(None, alias='cliClientID')
    client_id: Optional[str] = Field(None, alias='clientID')
    id_token_claims: Optional[Dict[str, OidcClaim]] = Field(None, alias='idTokenClaims')
    issuer: Optional[str] = None
    name: Optional[str] = None
    scopes: Optional[List[str]] = None


class ClusterSettings(BaseModel):
    app_label_key: Optional[str] = Field(None, alias='appLabelKey')
    apps_in_any_namespace_enabled: Optional[bool] = Field(None, alias='appsInAnyNamespaceEnabled')
    config_management_plugins: Optional[List[V1alpha1ConfigManagementPlugin]] = Field(
        None, alias='configManagementPlugins'
    )
    controller_namespace: Optional[str] = Field(None, alias='controllerNamespace')
    dex_config: Optional[ClusterDexConfig] = Field(None, alias='dexConfig')
    exec_enabled: Optional[bool] = Field(None, alias='execEnabled')
    google_analytics: Optional[ClusterGoogleAnalyticsConfig] = Field(None, alias='googleAnalytics')
    help: Optional[ClusterHelp] = None
    kustomize_options: Optional[V1alpha1KustomizeOptions] = Field(None, alias='kustomizeOptions')
    kustomize_versions: Optional[List[str]] = Field(None, alias='kustomizeVersions')
    oidc_config: Optional[ClusterOIDCConfig] = Field(None, alias='oidcConfig')
    password_pattern: Optional[str] = Field(None, alias='passwordPattern')
    plugins: Optional[List[ClusterPlugin]] = None
    resource_overrides: Optional[Dict[str, V1alpha1ResourceOverride]] = Field(None, alias='resourceOverrides')
    status_badge_enabled: Optional[bool] = Field(None, alias='statusBadgeEnabled')
    status_badge_root_url: Optional[str] = Field(None, alias='statusBadgeRootUrl')
    tracking_method: Optional[str] = Field(None, alias='trackingMethod')
    ui_banner_content: Optional[str] = Field(None, alias='uiBannerContent')
    ui_banner_permanent: Optional[bool] = Field(None, alias='uiBannerPermanent')
    ui_banner_position: Optional[str] = Field(None, alias='uiBannerPosition')
    ui_banner_url: Optional[str] = Field(None, alias='uiBannerURL')
    ui_css_url: Optional[str] = Field(None, alias='uiCssURL')
    url: Optional[str] = None
    user_logins_disabled: Optional[bool] = Field(None, alias='userLoginsDisabled')


class GpgkeyGnuPGPublicKeyCreateResponse(BaseModel):
    created: Optional[V1alpha1GnuPGPublicKeyList] = None
    skipped: Optional[List[str]] = Field(
        None, title='List of key IDs that haven been skipped because they already exist on the server'
    )


class ProjectSyncWindowsResponse(BaseModel):
    windows: Optional[List[V1alpha1SyncWindow]] = None


class RepositoryHelmAppSpec(BaseModel):
    file_parameters: Optional[List[V1alpha1HelmFileParameter]] = Field(
        None, alias='fileParameters', title='helm file parameters'
    )
    name: Optional[str] = None
    parameters: Optional[List[V1alpha1HelmParameter]] = Field(None, title='the output of `helm inspect values`')
    value_files: Optional[List[str]] = Field(None, alias='valueFiles')
    values: Optional[str] = Field(None, title='the contents of values.yaml')


class RepositoryRepoAppDetailsResponse(BaseModel):
    directory: Optional[RepositoryDirectoryAppSpec] = None
    helm: Optional[RepositoryHelmAppSpec] = None
    kustomize: Optional[RepositoryKustomizeAppSpec] = None
    plugin: Optional[RepositoryPluginAppSpec] = None
    type: Optional[str] = None


class V1EventSeries(BaseModel):
    count: Optional[int] = Field(None, title='Number of occurrences in this series up to the last heartbeat time')
    last_observed_time: Optional[V1MicroTime] = Field(None, alias='lastObservedTime')


class V1LabelSelector(BaseModel):
    match_expressions: Optional[List[V1LabelSelectorRequirement]] = Field(
        None,
        alias='matchExpressions',
        title='matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+optional',
    )
    match_labels: Optional[Dict[str, str]] = Field(
        None,
        alias='matchLabels',
        title=(
            'matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to'
            ' an element of matchExpressions, whose key field is "key", the\noperator is "In", and the values array'
            ' contains only "value". The requirements are ANDed.\n+optional'
        ),
    )


class V1LoadBalancerIngress(BaseModel):
    hostname: Optional[str] = Field(
        None,
        title=(
            'Hostname is set for load-balancer ingress points that are DNS based\n(typically AWS'
            ' load-balancers)\n+optional'
        ),
    )
    ip: Optional[str] = Field(
        None,
        title=(
            'IP is set for load-balancer ingress points that are IP based\n(typically GCE or OpenStack'
            ' load-balancers)\n+optional'
        ),
    )
    ports: Optional[List[V1PortStatus]] = Field(
        None,
        title=(
            'Ports is a list of records of service ports\nIf used, every port defined in the service should have an'
            ' entry in it\n+listType=atomic\n+optional'
        ),
    )


class V1ManagedFieldsEntry(BaseModel):
    api_version: Optional[str] = Field(
        None,
        alias='apiVersion',
        description=(
            'APIVersion defines the version of this resource that this field set\napplies to. The format is'
            ' "group/version" just like the top-level\nAPIVersion field. It is necessary to track the version of a'
            ' field\nset because it cannot be automatically converted.'
        ),
    )
    fields_type: Optional[str] = Field(
        None,
        alias='fieldsType',
        title=(
            'FieldsType is the discriminator for the different fields format and version.\nThere is currently only one'
            ' possible value: "FieldsV1"'
        ),
    )
    fields_v1: Optional[V1FieldsV1] = Field(None, alias='fieldsV1')
    manager: Optional[str] = Field(None, description='Manager is an identifier of the workflow managing these fields.')
    operation: Optional[str] = Field(
        None,
        description=(
            "Operation is the type of operation which lead to this ManagedFieldsEntry being created.\nThe only valid"
            " values for this field are 'Apply' and 'Update'."
        ),
    )
    subresource: Optional[str] = Field(
        None,
        description=(
            'Subresource is the name of the subresource used to update that object, or\nempty string if the object was'
            ' updated through the main resource. The\nvalue of this field is used to distinguish between managers,'
            ' even if they\nshare the same name. For example, a status update will be distinct from a\nregular update'
            ' using the same manager name.\nNote that the APIVersion field is not related to the Subresource field'
            ' and\nit always corresponds to the version of the main resource.'
        ),
    )
    time: Optional[V1Time] = None


class V1ObjectMeta(BaseModel):
    annotations: Optional[Dict[str, str]] = Field(
        None,
        title=(
            'Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to'
            ' store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying'
            ' objects.\nMore info: http://kubernetes.io/docs/user-guide/annotations\n+optional'
        ),
    )
    cluster_name: Optional[str] = Field(
        None,
        alias='clusterName',
        description=(
            'Deprecated: ClusterName is a legacy field that was always cleared by\nthe system and never used; it will'
            ' be removed completely in 1.25.\n\nThe name in the go struct is changed to help clients'
            ' detect\naccidental use.\n\n+optional'
        ),
    )
    creation_timestamp: Optional[V1Time] = Field(None, alias='creationTimestamp')
    deletion_grace_period_seconds: Optional[str] = Field(
        None,
        alias='deletionGracePeriodSeconds',
        title=(
            'Number of seconds allowed for this object to gracefully terminate before\nit will be removed from the'
            ' system. Only set when deletionTimestamp is also set.\nMay only be shortened.\nRead-only.\n+optional'
        ),
    )
    deletion_timestamp: Optional[V1Time] = Field(None, alias='deletionTimestamp')
    finalizers: Optional[List[str]] = Field(
        None,
        title=(
            'Must be empty before the object is deleted from the registry. Each entry\nis an identifier for the'
            ' responsible component that will remove the entry\nfrom the list. If the deletionTimestamp of the object'
            ' is non-nil, entries\nin this list can only be removed.\nFinalizers may be processed and removed in any'
            ' order.  Order is NOT enforced\nbecause it introduces significant risk of stuck finalizers.\nfinalizers'
            ' is a shared field, any actor with permission can reorder it.\nIf the finalizer list is processed in'
            ' order, then this can lead to a situation\nin which the component responsible for the first finalizer in'
            ' the list is\nwaiting for a signal (field value, external system, or other) produced by a\ncomponent'
            ' responsible for a finalizer later in the list, resulting in a deadlock.\nWithout enforced ordering'
            ' finalizers are free to order amongst themselves and\nare not vulnerable to ordering changes in the'
            ' list.\n+optional\n+patchStrategy=merge'
        ),
    )
    generate_name: Optional[str] = Field(
        None,
        alias='generateName',
        description=(
            'GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field'
            ' has not been provided.\nIf this field is used, the name returned to the client will be different\nthan'
            ' the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same'
            ' validation rules as the Name field,\nand may be truncated by the length of the suffix required to make'
            ' the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server'
            ' will return a 409.\n\nApplied only if Name is not specified.\nMore info:'
            ' https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional'
        ),
    )
    generation: Optional[str] = Field(
        None,
        title=(
            'A sequence number representing a specific generation of the desired state.\nPopulated by the system.'
            ' Read-only.\n+optional'
        ),
    )
    labels: Optional[Dict[str, str]] = Field(
        None,
        title=(
            'Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.'
            ' May match selectors of replication controllers\nand services.\nMore info:'
            ' http://kubernetes.io/docs/user-guide/labels\n+optional'
        ),
    )
    managed_fields: Optional[List[V1ManagedFieldsEntry]] = Field(
        None,
        alias='managedFields',
        description=(
            'ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that workflow. This'
            ' is mostly for internal\nhousekeeping, and users typically shouldn\'t need to set or\nunderstand this'
            ' field. A workflow can be the user\'s name, a\ncontroller\'s name, or the name of a specific apply path'
            ' like\n"ci-cd". The set of fields is always in the version that the\nworkflow used when modifying the'
            ' object.\n\n+optional'
        ),
    )
    name: Optional[str] = Field(
        None,
        title=(
            'Name must be unique within a namespace. Is required when creating resources, although\nsome resources may'
            ' allow a client to request the generation of an appropriate name\nautomatically. Name is primarily'
            ' intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info:'
            ' http://kubernetes.io/docs/user-guide/identifiers#names\n+optional'
        ),
    )
    namespace: Optional[str] = Field(
        None,
        description=(
            'Namespace defines the space within which each name must be unique. An empty namespace is\nequivalent to'
            ' the "default" namespace, but "default" is the canonical representation.\nNot all objects are required to'
            ' be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a'
            ' DNS_LABEL.\nCannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/namespaces\n+optional'
        ),
    )
    owner_references: Optional[List[V1OwnerReference]] = Field(
        None,
        alias='ownerReferences',
        title=(
            'List of objects depended by this object. If ALL objects in the list have\nbeen deleted, this object will'
            ' be garbage collected. If this object is managed by a controller,\nthen an entry in this list will point'
            ' to this controller, with the controller field set to true.\nThere cannot be more than one managing'
            ' controller.\n+optional\n+patchMergeKey=uid\n+patchStrategy=merge'
        ),
    )
    resource_version: Optional[str] = Field(
        None,
        alias='resourceVersion',
        description=(
            'An opaque value that represents the internal version of this object that can\nbe used by clients to'
            ' determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the'
            ' watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed'
            ' unmodified back to the server.\nThey may only be valid for a particular resource or set of'
            ' resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and'
            ' .\nMore info:'
            ' https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional'
        ),
    )
    self_link: Optional[str] = Field(
        None,
        alias='selfLink',
        title='Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.\n+optional',
    )
    uid: Optional[str] = Field(
        None,
        description=(
            'UID is the unique in time and space value for this object. It is typically generated by\nthe server on'
            ' successful creation of a resource and is not allowed to change on PUT\noperations.\n\nPopulated by the'
            ' system.\nRead-only.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#uids\n+optional'
        ),
    )


class V1alpha1AppProjectSpec(BaseModel):
    cluster_resource_blacklist: Optional[List[V1GroupKind]] = Field(
        None,
        alias='clusterResourceBlacklist',
        title='ClusterResourceBlacklist contains list of blacklisted cluster level resources',
    )
    cluster_resource_whitelist: Optional[List[V1GroupKind]] = Field(
        None,
        alias='clusterResourceWhitelist',
        title='ClusterResourceWhitelist contains list of whitelisted cluster level resources',
    )
    description: Optional[str] = Field(None, title='Description contains optional project description')
    destinations: Optional[List[V1alpha1ApplicationDestination]] = Field(
        None, title='Destinations contains list of destinations available for deployment'
    )
    namespace_resource_blacklist: Optional[List[V1GroupKind]] = Field(
        None,
        alias='namespaceResourceBlacklist',
        title='NamespaceResourceBlacklist contains list of blacklisted namespace level resources',
    )
    namespace_resource_whitelist: Optional[List[V1GroupKind]] = Field(
        None,
        alias='namespaceResourceWhitelist',
        title='NamespaceResourceWhitelist contains list of whitelisted namespace level resources',
    )
    orphaned_resources: Optional[V1alpha1OrphanedResourcesMonitorSettings] = Field(None, alias='orphanedResources')
    permit_only_project_scoped_clusters: Optional[bool] = Field(
        None,
        alias='permitOnlyProjectScopedClusters',
        title=(
            'PermitOnlyProjectScopedClusters determines whether destinations can only reference clusters which are'
            ' project-scoped'
        ),
    )
    roles: Optional[List[V1alpha1ProjectRole]] = Field(
        None, title='Roles are user defined RBAC roles associated with this project'
    )
    signature_keys: Optional[List[V1alpha1SignatureKey]] = Field(
        None,
        alias='signatureKeys',
        title=(
            'SignatureKeys contains a list of PGP key IDs that commits in Git must be signed with in order to be'
            ' allowed for sync'
        ),
    )
    source_namespaces: Optional[List[str]] = Field(
        None,
        alias='sourceNamespaces',
        title='SourceNamespaces defines the namespaces application resources are allowed to be created in',
    )
    source_repos: Optional[List[str]] = Field(
        None,
        alias='sourceRepos',
        title='SourceRepos contains list of repository URLs which can be used for deployment',
    )
    sync_windows: Optional[List[V1alpha1SyncWindow]] = Field(
        None, alias='syncWindows', title='SyncWindows controls when syncs can be run for apps in this project'
    )


class V1alpha1AppProjectStatus(BaseModel):
    jwt_tokens_by_role: Optional[Dict[str, V1alpha1JWTTokens]] = Field(
        None, alias='jwtTokensByRole', title='JWTTokensByRole contains a list of JWT tokens issued for a given role'
    )


class V1alpha1ApplicationSourceHelm(BaseModel):
    file_parameters: Optional[List[V1alpha1HelmFileParameter]] = Field(
        None, alias='fileParameters', title='FileParameters are file parameters to the helm template'
    )
    ignore_missing_value_files: Optional[bool] = Field(
        None,
        alias='ignoreMissingValueFiles',
        title=(
            'IgnoreMissingValueFiles prevents helm template from failing when valueFiles do not exist locally by not'
            ' appending them to helm template --values'
        ),
    )
    parameters: Optional[List[V1alpha1HelmParameter]] = Field(
        None,
        title=(
            'Parameters is a list of Helm parameters which are passed to the helm template command upon manifest'
            ' generation'
        ),
    )
    pass_credentials: Optional[bool] = Field(
        None,
        alias='passCredentials',
        title="PassCredentials pass credentials to all domains (Helm's --pass-credentials)",
    )
    release_name: Optional[str] = Field(
        None,
        alias='releaseName',
        title='ReleaseName is the Helm release name to use. If omitted it will use the application name',
    )
    skip_crds: Optional[bool] = Field(
        None,
        alias='skipCrds',
        title="SkipCrds skips custom resource definition installation step (Helm's --skip-crds)",
    )
    value_files: Optional[List[str]] = Field(
        None, alias='valueFiles', title='ValuesFiles is a list of Helm value files to use when generating a template'
    )
    values: Optional[str] = Field(
        None, title='Values specifies Helm values to be passed to helm template, typically defined as a block'
    )
    version: Optional[str] = Field(None, title='Version is the Helm version to use for templating ("3")')


class V1alpha1ApplicationSourceJsonnet(BaseModel):
    ext_vars: Optional[List[V1alpha1JsonnetVar]] = Field(
        None, alias='extVars', title='ExtVars is a list of Jsonnet External Variables'
    )
    libs: Optional[List[str]] = Field(None, title='Additional library search dirs')
    tlas: Optional[List[V1alpha1JsonnetVar]] = Field(None, title='TLAS is a list of Jsonnet Top-level Arguments')


class V1alpha1ApplicationSourceKustomize(BaseModel):
    common_annotations: Optional[Dict[str, str]] = Field(
        None,
        alias='commonAnnotations',
        title='CommonAnnotations is a list of additional annotations to add to rendered manifests',
    )
    common_annotations_envsubst: Optional[bool] = Field(
        None,
        alias='commonAnnotationsEnvsubst',
        title='CommonAnnotationsEnvsubst specifies whether to apply env variables substitution for annotation values',
    )
    common_labels: Optional[Dict[str, str]] = Field(
        None, alias='commonLabels', title='CommonLabels is a list of additional labels to add to rendered manifests'
    )
    force_common_annotations: Optional[bool] = Field(
        None,
        alias='forceCommonAnnotations',
        title=(
            'ForceCommonAnnotations specifies whether to force applying common annotations to resources for Kustomize'
            ' apps'
        ),
    )
    force_common_labels: Optional[bool] = Field(
        None,
        alias='forceCommonLabels',
        title='ForceCommonLabels specifies whether to force applying common labels to resources for Kustomize apps',
    )
    images: Optional[List[str]] = Field(None, title='Images is a list of Kustomize image override specifications')
    name_prefix: Optional[str] = Field(
        None, alias='namePrefix', title='NamePrefix is a prefix appended to resources for Kustomize apps'
    )
    name_suffix: Optional[str] = Field(
        None, alias='nameSuffix', title='NameSuffix is a suffix appended to resources for Kustomize apps'
    )
    namespace: Optional[str] = Field(None, title='Namespace sets the namespace that Kustomize adds to all resources')
    replicas: Optional[List[V1alpha1KustomizeReplica]] = Field(
        None, title='Replicas is a list of Kustomize Replicas override specifications'
    )
    version: Optional[str] = Field(
        None, title='Version controls which version of Kustomize to use for rendering manifests'
    )


class V1alpha1ApplicationSourcePlugin(BaseModel):
    env: Optional[List[Applicationv1alpha1EnvEntry]] = None
    name: Optional[str] = None
    parameters: Optional[List[V1alpha1ApplicationSourcePluginParameter]] = None


class V1alpha1BasicAuthBitbucketServer(BaseModel):
    password_ref: Optional[V1alpha1SecretRef] = Field(None, alias='passwordRef')
    username: Optional[str] = Field(None, title='Username for Basic auth')


class V1alpha1ClusterConfig(BaseModel):
    aws_auth_config: Optional[V1alpha1AWSAuthConfig] = Field(None, alias='awsAuthConfig')
    bearer_token: Optional[str] = Field(
        None,
        alias='bearerToken',
        description=(
            'Server requires Bearer authentication. This client will not attempt to use\nrefresh tokens for an OAuth2'
            ' flow.\nTODO: demonstrate an OAuth2 compatible client.'
        ),
    )
    exec_provider_config: Optional[V1alpha1ExecProviderConfig] = Field(None, alias='execProviderConfig')
    password: Optional[str] = None
    tls_client_config: Optional[V1alpha1TLSClientConfig] = Field(None, alias='tlsClientConfig')
    username: Optional[str] = Field(None, title='Server requires Basic authentication')


class V1alpha1ClusterInfo(BaseModel):
    api_versions: Optional[List[str]] = Field(
        None, alias='apiVersions', title='APIVersions contains list of API versions supported by the cluster'
    )
    applications_count: Optional[str] = Field(
        None,
        alias='applicationsCount',
        title='ApplicationsCount is the number of applications managed by Argo CD on the cluster',
    )
    cache_info: Optional[V1alpha1ClusterCacheInfo] = Field(None, alias='cacheInfo')
    connection_state: Optional[V1alpha1ConnectionState] = Field(None, alias='connectionState')
    server_version: Optional[str] = Field(
        None,
        alias='serverVersion',
        title='ServerVersion contains information about the Kubernetes version of the cluster',
    )


class V1alpha1HostInfo(BaseModel):
    name: Optional[str] = None
    resources_info: Optional[List[V1alpha1HostResourceInfo]] = Field(None, alias='resourcesInfo')
    system_info: Optional[V1NodeSystemInfo] = Field(None, alias='systemInfo')


class V1alpha1PullRequestGeneratorBitbucketServer(BaseModel):
    api: Optional[str] = Field(
        None, description='The Bitbucket REST API URL to talk to e.g. https://bitbucket.org/rest Required.'
    )
    basic_auth: Optional[V1alpha1BasicAuthBitbucketServer] = Field(None, alias='basicAuth')
    project: Optional[str] = Field(None, description='Project to scan. Required.')
    repo: Optional[str] = Field(None, description='Repo name to scan. Required.')


class V1alpha1PullRequestGeneratorGitLab(BaseModel):
    api: Optional[str] = Field(None, description='The GitLab API URL to talk to. If blank, uses https://gitlab.com/.')
    labels: Optional[List[str]] = Field(None, title='Labels is used to filter the MRs that you want to target')
    project: Optional[str] = Field(None, description='GitLab project to scan. Required.')
    pull_request_state: Optional[str] = Field(
        None,
        alias='pullRequestState',
        title=(
            'PullRequestState is an additional MRs filter to get only those with a certain state. Default: "" (all'
            ' states)'
        ),
    )
    token_ref: Optional[V1alpha1SecretRef] = Field(None, alias='tokenRef')


class V1alpha1PullRequestGeneratorGitea(BaseModel):
    api: Optional[str] = Field(None, title='The Gitea API URL to talk to. Required')
    insecure: Optional[bool] = Field(
        None, description='Allow insecure tls, for self-signed certificates; default: false.'
    )
    owner: Optional[str] = Field(None, description='Gitea org or user to scan. Required.')
    repo: Optional[str] = Field(None, description='Gitea repo name to scan. Required.')
    token_ref: Optional[V1alpha1SecretRef] = Field(None, alias='tokenRef')


class V1alpha1PullRequestGeneratorGithub(BaseModel):
    api: Optional[str] = Field(
        None, description='The GitHub API URL to talk to. If blank, use https://api.github.com/.'
    )
    app_secret_name: Optional[str] = Field(
        None,
        alias='appSecretName',
        description=(
            'AppSecretName is a reference to a GitHub App repo-creds secret with permission to access pull requests.'
        ),
    )
    labels: Optional[List[str]] = Field(None, title='Labels is used to filter the PRs that you want to target')
    owner: Optional[str] = Field(None, description='GitHub org or user to scan. Required.')
    repo: Optional[str] = Field(None, description='GitHub repo name to scan. Required.')
    token_ref: Optional[V1alpha1SecretRef] = Field(None, alias='tokenRef')


class V1alpha1ResourceAction(BaseModel):
    disabled: Optional[bool] = None
    name: Optional[str] = None
    params: Optional[List[V1alpha1ResourceActionParam]] = None


class V1alpha1ResourceNetworkingInfo(BaseModel):
    external_ur_ls: Optional[List[str]] = Field(
        None,
        alias='externalURLs',
        description=(
            'ExternalURLs holds list of URLs which should be available externally. List is populated for ingress'
            ' resources using rules hostnames.'
        ),
    )
    ingress: Optional[List[V1LoadBalancerIngress]] = None
    labels: Optional[Dict[str, str]] = None
    target_labels: Optional[Dict[str, str]] = Field(None, alias='targetLabels')
    target_refs: Optional[List[V1alpha1ResourceRef]] = Field(None, alias='targetRefs')


class V1alpha1ResourceNode(BaseModel):
    created_at: Optional[V1Time] = Field(None, alias='createdAt')
    health: Optional[V1alpha1HealthStatus] = None
    images: Optional[List[str]] = None
    info: Optional[List[V1alpha1InfoItem]] = None
    networking_info: Optional[V1alpha1ResourceNetworkingInfo] = Field(None, alias='networkingInfo')
    parent_refs: Optional[List[V1alpha1ResourceRef]] = Field(None, alias='parentRefs')
    resource_ref: Optional[V1alpha1ResourceRef] = Field(None, alias='resourceRef')
    resource_version: Optional[str] = Field(None, alias='resourceVersion')


class V1alpha1SCMProviderGeneratorAzureDevOps(BaseModel):
    access_token_ref: Optional[V1alpha1SecretRef] = Field(None, alias='accessTokenRef')
    all_branches: Optional[bool] = Field(
        None, alias='allBranches', description='Scan all branches instead of just the default branch.'
    )
    api: Optional[str] = Field(None, description='The URL to Azure DevOps. If blank, use https://dev.azure.com.')
    organization: Optional[str] = Field(
        None, description='Azure Devops organization. Required. E.g. "my-organization".'
    )
    team_project: Optional[str] = Field(
        None, alias='teamProject', description='Azure Devops team project. Required. E.g. "my-team".'
    )


class V1alpha1SCMProviderGeneratorBitbucket(BaseModel):
    all_branches: Optional[bool] = Field(
        None, alias='allBranches', description='Scan all branches instead of just the main branch.'
    )
    app_password_ref: Optional[V1alpha1SecretRef] = Field(None, alias='appPasswordRef')
    owner: Optional[str] = Field(None, description='Bitbucket workspace to scan. Required.')
    user: Optional[str] = Field(
        None,
        title=(
            'Bitbucket user to use when authenticating.  Should have a "member" role to be able to read all'
            ' repositories and branches.  Required'
        ),
    )


class V1alpha1SCMProviderGeneratorBitbucketServer(BaseModel):
    all_branches: Optional[bool] = Field(
        None, alias='allBranches', description='Scan all branches instead of just the default branch.'
    )
    api: Optional[str] = Field(None, description='The Bitbucket Server REST API URL to talk to. Required.')
    basic_auth: Optional[V1alpha1BasicAuthBitbucketServer] = Field(None, alias='basicAuth')
    project: Optional[str] = Field(None, description='Project to scan. Required.')


class V1alpha1SCMProviderGeneratorGitea(BaseModel):
    all_branches: Optional[bool] = Field(
        None, alias='allBranches', description='Scan all branches instead of just the default branch.'
    )
    api: Optional[str] = Field(None, description='The Gitea URL to talk to. For example https://gitea.mydomain.com/.')
    insecure: Optional[bool] = Field(None, title='Allow self-signed TLS / Certificates; default: false')
    owner: Optional[str] = Field(None, description='Gitea organization or user to scan. Required.')
    token_ref: Optional[V1alpha1SecretRef] = Field(None, alias='tokenRef')


class V1alpha1SCMProviderGeneratorGithub(BaseModel):
    all_branches: Optional[bool] = Field(
        None, alias='allBranches', description='Scan all branches instead of just the default branch.'
    )
    api: Optional[str] = Field(
        None, description='The GitHub API URL to talk to. If blank, use https://api.github.com/.'
    )
    app_secret_name: Optional[str] = Field(
        None, alias='appSecretName', description='AppSecretName is a reference to a GitHub App repo-creds secret.'
    )
    organization: Optional[str] = Field(None, description='GitHub org to scan. Required.')
    token_ref: Optional[V1alpha1SecretRef] = Field(None, alias='tokenRef')


class V1alpha1SCMProviderGeneratorGitlab(BaseModel):
    all_branches: Optional[bool] = Field(
        None, alias='allBranches', description='Scan all branches instead of just the default branch.'
    )
    api: Optional[str] = Field(None, description='The Gitlab API URL to talk to.')
    group: Optional[str] = Field(
        None,
        description=(
            'Gitlab group to scan. Required.  You can use either the project id (recommended) or the full namespaced'
            ' path.'
        ),
    )
    include_subgroups: Optional[bool] = Field(
        None,
        alias='includeSubgroups',
        title='Recurse through subgroups (true) or scan only the base group (false).  Defaults to "false"',
    )
    token_ref: Optional[V1alpha1SecretRef] = Field(None, alias='tokenRef')


class V1alpha1SyncPolicy(BaseModel):
    automated: Optional[V1alpha1SyncPolicyAutomated] = None
    managed_namespace_metadata: Optional[V1alpha1ManagedNamespaceMetadata] = Field(
        None, alias='managedNamespaceMetadata'
    )
    retry: Optional[V1alpha1RetryStrategy] = None
    sync_options: Optional[List[str]] = Field(
        None, alias='syncOptions', title='Options allow you to specify whole app sync-options'
    )


class V1alpha1SyncStrategy(BaseModel):
    apply: Optional[V1alpha1SyncStrategyApply] = None
    hook: Optional[V1alpha1SyncStrategyHook] = None


class ApplicationApplicationSyncRequest(BaseModel):
    app_namespace: Optional[str] = Field(None, alias='appNamespace')
    dry_run: Optional[bool] = Field(None, alias='dryRun')
    infos: Optional[List[V1alpha1Info]] = None
    manifests: Optional[List[str]] = None
    name: Optional[str] = None
    prune: Optional[bool] = None
    resources: Optional[List[V1alpha1SyncOperationResource]] = None
    retry_strategy: Optional[V1alpha1RetryStrategy] = Field(None, alias='retryStrategy')
    revision: Optional[str] = None
    strategy: Optional[V1alpha1SyncStrategy] = None
    sync_options: Optional[ApplicationSyncOptions] = Field(None, alias='syncOptions')


class ApplicationResourceActionsListResponse(BaseModel):
    actions: Optional[List[V1alpha1ResourceAction]] = None


class V1Event(BaseModel):
    action: Optional[str] = Field(
        None, title='What action was taken/failed regarding to the Regarding object.\n+optional'
    )
    count: Optional[int] = Field(None, title='The number of times this event has occurred.\n+optional')
    event_time: Optional[V1MicroTime] = Field(None, alias='eventTime')
    first_timestamp: Optional[V1Time] = Field(None, alias='firstTimestamp')
    involved_object: Optional[V1ObjectReference] = Field(None, alias='involvedObject')
    last_timestamp: Optional[V1Time] = Field(None, alias='lastTimestamp')
    message: Optional[str] = Field(
        None,
        title=(
            'A human-readable description of the status of this operation.\nTODO: decide on maximum length.\n+optional'
        ),
    )
    metadata: Optional[V1ObjectMeta] = None
    reason: Optional[str] = Field(
        None,
        title=(
            "This should be a short, machine understandable string that gives the reason\nfor the transition into the"
            " object's current status.\nTODO: provide exact specification for format.\n+optional"
        ),
    )
    related: Optional[V1ObjectReference] = None
    reporting_component: Optional[str] = Field(
        None,
        alias='reportingComponent',
        title='Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.\n+optional',
    )
    reporting_instance: Optional[str] = Field(
        None, alias='reportingInstance', title='ID of the controller instance, e.g. `kubelet-xyzf`.\n+optional'
    )
    series: Optional[V1EventSeries] = None
    source: Optional[V1EventSource] = None
    type: Optional[str] = Field(
        None, title='Type of this event (Normal, Warning), new types could be added in the future\n+optional'
    )


class V1EventList(BaseModel):
    items: Optional[List[V1Event]] = Field(None, title='List of events')
    metadata: Optional[V1ListMeta] = None


class V1alpha1AppProject(BaseModel):
    metadata: Optional[V1ObjectMeta] = None
    spec: Optional[V1alpha1AppProjectSpec] = None
    status: Optional[V1alpha1AppProjectStatus] = None


class V1alpha1AppProjectList(BaseModel):
    items: Optional[List[V1alpha1AppProject]] = None
    metadata: Optional[V1ListMeta] = None


class V1alpha1ApplicationSourceDirectory(BaseModel):
    exclude: Optional[str] = Field(
        None,
        title=(
            'Exclude contains a glob pattern to match paths against that should be explicitly excluded from being used'
            ' during manifest generation'
        ),
    )
    include: Optional[str] = Field(
        None,
        title=(
            'Include contains a glob pattern to match paths against that should be explicitly included during manifest'
            ' generation'
        ),
    )
    jsonnet: Optional[V1alpha1ApplicationSourceJsonnet] = None
    recurse: Optional[bool] = Field(
        None, title='Recurse specifies whether to scan a directory recursively for manifests'
    )


class V1alpha1ApplicationTree(BaseModel):
    hosts: Optional[List[V1alpha1HostInfo]] = Field(
        None, title='Hosts holds list of Kubernetes nodes that run application related pods'
    )
    nodes: Optional[List[V1alpha1ResourceNode]] = Field(
        None,
        description=(
            'Nodes contains list of nodes which either directly managed by the application and children of directly'
            ' managed nodes.'
        ),
    )
    orphaned_nodes: Optional[List[V1alpha1ResourceNode]] = Field(
        None,
        alias='orphanedNodes',
        description=(
            'OrphanedNodes contains if or orphaned nodes: nodes which are not managed by the app but in the same'
            ' namespace. List is populated only if orphaned resources enabled in app project.'
        ),
    )


class V1alpha1Cluster(BaseModel):
    annotations: Optional[Dict[str, str]] = Field(None, title='Annotations for cluster secret metadata')
    cluster_resources: Optional[bool] = Field(
        None,
        alias='clusterResources',
        description=(
            'Indicates if cluster level resources should be managed. This setting is used only if cluster is connected'
            ' in a namespaced mode.'
        ),
    )
    config: Optional[V1alpha1ClusterConfig] = None
    connection_state: Optional[V1alpha1ConnectionState] = Field(None, alias='connectionState')
    info: Optional[V1alpha1ClusterInfo] = None
    labels: Optional[Dict[str, str]] = Field(None, title='Labels for cluster secret metadata')
    name: Optional[str] = Field(None, title='Name of the cluster. If omitted, will use the server address')
    namespaces: Optional[List[str]] = Field(
        None,
        description=(
            'Holds list of namespaces which are accessible in that cluster. Cluster level resources will be ignored if'
            ' namespace list is not empty.'
        ),
    )
    project: Optional[str] = Field(
        None,
        title=(
            'Reference between project and cluster that allow you automatically to be added as item inside'
            ' Destinations project entity'
        ),
    )
    refresh_requested_at: Optional[V1Time] = Field(None, alias='refreshRequestedAt')
    server: Optional[str] = Field(None, title='Server is the API server URL of the Kubernetes cluster')
    server_version: Optional[str] = Field(
        None, alias='serverVersion', title='DEPRECATED: use Info.ServerVersion field instead.\nThe server version'
    )
    shard: Optional[str] = Field(
        None,
        description=(
            'Shard contains optional shard number. Calculated on the fly by the application controller if not'
            ' specified.'
        ),
    )


class V1alpha1ClusterList(BaseModel):
    items: Optional[List[V1alpha1Cluster]] = None
    metadata: Optional[V1ListMeta] = None


class ProjectDetailedProjectsResponse(BaseModel):
    clusters: Optional[List[V1alpha1Cluster]] = None
    global_projects: Optional[List[V1alpha1AppProject]] = Field(None, alias='globalProjects')
    project: Optional[V1alpha1AppProject] = None
    repositories: Optional[List[V1alpha1Repository]] = None


class ProjectGlobalProjectsResponse(BaseModel):
    items: Optional[List[V1alpha1AppProject]] = None


class ProjectProjectCreateRequest(BaseModel):
    project: Optional[V1alpha1AppProject] = None
    upsert: Optional[bool] = None


class ProjectProjectUpdateRequest(BaseModel):
    project: Optional[V1alpha1AppProject] = None


class V1alpha1ApplicationSource(BaseModel):
    chart: Optional[str] = Field(
        None,
        description='Chart is a Helm chart name, and must be specified for applications sourced from a Helm repo.',
    )
    directory: Optional[V1alpha1ApplicationSourceDirectory] = None
    helm: Optional[V1alpha1ApplicationSourceHelm] = None
    kustomize: Optional[V1alpha1ApplicationSourceKustomize] = None
    path: Optional[str] = Field(
        None,
        description=(
            'Path is a directory path within the Git repository, and is only valid for applications sourced from Git.'
        ),
    )
    plugin: Optional[V1alpha1ApplicationSourcePlugin] = None
    ref: Optional[str] = Field(
        None,
        description=(
            'Ref is reference to another source within sources field. This field will not be used if used with a'
            ' `source` tag.'
        ),
    )
    repo_url: Optional[str] = Field(
        None,
        alias='repoURL',
        title='RepoURL is the URL to the repository (Git or Helm) that contains the application manifests',
    )
    target_revision: Optional[str] = Field(
        None,
        alias='targetRevision',
        description=(
            "TargetRevision defines the revision of the source to sync the application to.\nIn case of Git, this can"
            " be commit, tag, or branch. If omitted, will equal to HEAD.\nIn case of Helm, this is a semver tag for"
            " the Chart's version."
        ),
    )


class V1alpha1ApplicationSpec(BaseModel):
    destination: Optional[V1alpha1ApplicationDestination] = None
    ignore_differences: Optional[List[V1alpha1ResourceIgnoreDifferences]] = Field(
        None,
        alias='ignoreDifferences',
        title='IgnoreDifferences is a list of resources and their fields which should be ignored during comparison',
    )
    info: Optional[List[V1alpha1Info]] = Field(
        None,
        title=(
            'Info contains a list of information (URLs, email addresses, and plain text) that relates to the'
            ' application'
        ),
    )
    project: Optional[str] = Field(
        None,
        description=(
            "Project is a reference to the project this application belongs to.\nThe empty string means that"
            " application belongs to the 'default' project."
        ),
    )
    revision_history_limit: Optional[str] = Field(
        None,
        alias='revisionHistoryLimit',
        description=(
            "RevisionHistoryLimit limits the number of items kept in the application's revision history, which is used"
            " for informational purposes as well as for rollbacks to previous versions.\nThis should only be changed"
            " in exceptional circumstances.\nSetting to zero will store no history. This will reduce storage"
            " used.\nIncreasing will increase the space used to store the history, so we do not recommend increasing"
            " it.\nDefault is 10."
        ),
    )
    source: Optional[V1alpha1ApplicationSource] = None
    sources: Optional[List[V1alpha1ApplicationSource]] = Field(
        None, title="Sources is a reference to the location of the application's manifests or chart"
    )
    sync_policy: Optional[V1alpha1SyncPolicy] = Field(None, alias='syncPolicy')


class V1alpha1ComparedTo(BaseModel):
    destination: Optional[V1alpha1ApplicationDestination] = None
    source: Optional[V1alpha1ApplicationSource] = None
    sources: Optional[List[V1alpha1ApplicationSource]] = Field(
        None, title="Sources is a reference to the application's multiple sources used for comparison"
    )


class V1alpha1RevisionHistory(BaseModel):
    deploy_started_at: Optional[V1Time] = Field(None, alias='deployStartedAt')
    deployed_at: Optional[V1Time] = Field(None, alias='deployedAt')
    id: Optional[str] = Field(None, title='ID is an auto incrementing identifier of the RevisionHistory')
    revision: Optional[str] = Field(None, title='Revision holds the revision the sync was performed against')
    revisions: Optional[List[str]] = Field(
        None, title='Revisions holds the revision of each source in sources field the sync was performed against'
    )
    source: Optional[V1alpha1ApplicationSource] = None
    sources: Optional[List[V1alpha1ApplicationSource]] = Field(
        None, title='Sources is a reference to the application sources used for the sync operation'
    )


class V1alpha1SyncOperation(BaseModel):
    dry_run: Optional[bool] = Field(
        None,
        alias='dryRun',
        title='DryRun specifies to perform a `kubectl apply --dry-run` without actually performing the sync',
    )
    manifests: Optional[List[str]] = Field(
        None, title='Manifests is an optional field that overrides sync source with a local directory for development'
    )
    prune: Optional[bool] = Field(
        None, title='Prune specifies to delete resources from the cluster that are no longer tracked in git'
    )
    resources: Optional[List[V1alpha1SyncOperationResource]] = Field(
        None, title='Resources describes which resources shall be part of the sync'
    )
    revision: Optional[str] = Field(
        None,
        description=(
            'Revision is the revision (Git) or chart version (Helm) which to sync the application to\nIf omitted, will'
            ' use the revision specified in app spec.'
        ),
    )
    revisions: Optional[List[str]] = Field(
        None,
        description=(
            'Revisions is the list of revision (Git) or chart version (Helm) which to sync each source in sources'
            ' field for the application to\nIf omitted, will use the revision specified in app spec.'
        ),
    )
    source: Optional[V1alpha1ApplicationSource] = None
    sources: Optional[List[V1alpha1ApplicationSource]] = Field(
        None,
        title=(
            'Sources overrides the source definition set in the application.\nThis is typically set in a Rollback'
            ' operation and is nil during a Sync operation'
        ),
    )
    sync_options: Optional[List[str]] = Field(
        None, alias='syncOptions', title='SyncOptions provide per-sync sync-options, e.g. Validate=false'
    )
    sync_strategy: Optional[V1alpha1SyncStrategy] = Field(None, alias='syncStrategy')


class V1alpha1SyncOperationResult(BaseModel):
    resources: Optional[List[V1alpha1ResourceResult]] = Field(
        None, title='Resources contains a list of sync result items for each individual resource in a sync operation'
    )
    revision: Optional[str] = Field(None, title='Revision holds the revision this sync operation was performed to')
    revisions: Optional[List[str]] = Field(
        None,
        title=(
            'Revisions holds the revision this sync operation was performed for respective indexed source in sources'
            ' field'
        ),
    )
    source: Optional[V1alpha1ApplicationSource] = None
    sources: Optional[List[V1alpha1ApplicationSource]] = Field(
        None, title='Source records the application source information of the sync, used for comparing auto-sync'
    )


class V1alpha1SyncStatus(BaseModel):
    compared_to: Optional[V1alpha1ComparedTo] = Field(None, alias='comparedTo')
    revision: Optional[str] = Field(
        None, title='Revision contains information about the revision the comparison has been performed to'
    )
    revisions: Optional[List[str]] = Field(
        None,
        title=(
            'Revisions contains information about the revisions of multiple sources the comparison has been'
            ' performed to'
        ),
    )
    status: Optional[str] = Field(None, title='Status is the sync state of the comparison')


class RepositoryRepoAppDetailsQuery(BaseModel):
    app_name: Optional[str] = Field(None, alias='appName')
    app_project: Optional[str] = Field(None, alias='appProject')
    source: Optional[V1alpha1ApplicationSource] = None


class V1alpha1ApplicationSetTemplate(BaseModel):
    metadata: Optional[V1alpha1ApplicationSetTemplateMeta] = None
    spec: Optional[V1alpha1ApplicationSpec] = None


class V1alpha1ClusterGenerator(BaseModel):
    selector: Optional[V1LabelSelector] = None
    template: Optional[V1alpha1ApplicationSetTemplate] = None
    values: Optional[Dict[str, str]] = Field(
        None, title='Values contains key/value pairs which are passed directly as parameters to the template'
    )


class V1alpha1DuckTypeGenerator(BaseModel):
    config_map_ref: Optional[str] = Field(
        None,
        alias='configMapRef',
        title=(
            'ConfigMapRef is a ConfigMap with the duck type definitions needed to retrieve the data\n             this'
            ' includes apiVersion(group/version), kind, matchKey and validation settings\nName is the resource name of'
            ' the kind, group and version, defined in the ConfigMapRef\nRequeueAfterSeconds is how long before the'
            ' duckType will be rechecked for a change'
        ),
    )
    label_selector: Optional[V1LabelSelector] = Field(None, alias='labelSelector')
    name: Optional[str] = None
    requeue_after_seconds: Optional[str] = Field(None, alias='requeueAfterSeconds')
    template: Optional[V1alpha1ApplicationSetTemplate] = None
    values: Optional[Dict[str, str]] = Field(
        None, title='Values contains key/value pairs which are passed directly as parameters to the template'
    )


class V1alpha1GitGenerator(BaseModel):
    directories: Optional[List[V1alpha1GitDirectoryGeneratorItem]] = None
    files: Optional[List[V1alpha1GitFileGeneratorItem]] = None
    path_param_prefix: Optional[str] = Field(None, alias='pathParamPrefix')
    repo_url: Optional[str] = Field(None, alias='repoURL')
    requeue_after_seconds: Optional[str] = Field(None, alias='requeueAfterSeconds')
    revision: Optional[str] = None
    template: Optional[V1alpha1ApplicationSetTemplate] = None


class V1alpha1ListGenerator(BaseModel):
    elements: Optional[List[V1JSON]] = None
    elements_yaml: Optional[str] = Field(None, alias='elementsYaml')
    template: Optional[V1alpha1ApplicationSetTemplate] = None


class V1alpha1Operation(BaseModel):
    info: Optional[List[V1alpha1Info]] = Field(None, title='Info is a list of informational items for this operation')
    initiated_by: Optional[V1alpha1OperationInitiator] = Field(None, alias='initiatedBy')
    retry: Optional[V1alpha1RetryStrategy] = None
    sync: Optional[V1alpha1SyncOperation] = None


class V1alpha1OperationState(BaseModel):
    finished_at: Optional[V1Time] = Field(None, alias='finishedAt')
    message: Optional[str] = Field(
        None,
        description='Message holds any pertinent messages when attempting to perform operation (typically errors).',
    )
    operation: Optional[V1alpha1Operation] = None
    phase: Optional[str] = Field(None, title='Phase is the current phase of the operation')
    retry_count: Optional[str] = Field(None, alias='retryCount', title='RetryCount contains time of operation retries')
    started_at: Optional[V1Time] = Field(None, alias='startedAt')
    sync_result: Optional[V1alpha1SyncOperationResult] = Field(None, alias='syncResult')


class V1alpha1PullRequestGenerator(BaseModel):
    bitbucket_server: Optional[V1alpha1PullRequestGeneratorBitbucketServer] = Field(None, alias='bitbucketServer')
    filters: Optional[List[V1alpha1PullRequestGeneratorFilter]] = Field(
        None, description='Filters for which pull requests should be considered.'
    )
    gitea: Optional[V1alpha1PullRequestGeneratorGitea] = None
    github: Optional[V1alpha1PullRequestGeneratorGithub] = None
    gitlab: Optional[V1alpha1PullRequestGeneratorGitLab] = None
    requeue_after_seconds: Optional[str] = Field(None, alias='requeueAfterSeconds', description='Standard parameters.')
    template: Optional[V1alpha1ApplicationSetTemplate] = None


class V1alpha1SCMProviderGenerator(BaseModel):
    azure_dev_ops: Optional[V1alpha1SCMProviderGeneratorAzureDevOps] = Field(None, alias='azureDevOps')
    bitbucket: Optional[V1alpha1SCMProviderGeneratorBitbucket] = None
    bitbucket_server: Optional[V1alpha1SCMProviderGeneratorBitbucketServer] = Field(None, alias='bitbucketServer')
    clone_protocol: Optional[str] = Field(
        None,
        alias='cloneProtocol',
        description=(
            'Which protocol to use for the SCM URL. Default is provider-specific but ssh if possible. Not all'
            ' providers\nnecessarily support all protocols.'
        ),
    )
    filters: Optional[List[V1alpha1SCMProviderGeneratorFilter]] = Field(
        None, description='Filters for which repos should be considered.'
    )
    gitea: Optional[V1alpha1SCMProviderGeneratorGitea] = None
    github: Optional[V1alpha1SCMProviderGeneratorGithub] = None
    gitlab: Optional[V1alpha1SCMProviderGeneratorGitlab] = None
    requeue_after_seconds: Optional[str] = Field(None, alias='requeueAfterSeconds', description='Standard parameters.')
    template: Optional[V1alpha1ApplicationSetTemplate] = None


class V1alpha1ApplicationSetNestedGenerator(BaseModel):
    cluster_decision_resource: Optional[V1alpha1DuckTypeGenerator] = Field(None, alias='clusterDecisionResource')
    clusters: Optional[V1alpha1ClusterGenerator] = None
    git: Optional[V1alpha1GitGenerator] = None
    list: Optional[V1alpha1ListGenerator] = None
    matrix: Optional[V1JSON] = None
    merge: Optional[V1JSON] = None
    pull_request: Optional[V1alpha1PullRequestGenerator] = Field(None, alias='pullRequest')
    scm_provider: Optional[V1alpha1SCMProviderGenerator] = Field(None, alias='scmProvider')
    selector: Optional[V1LabelSelector] = None


class V1alpha1ApplicationStatus(BaseModel):
    conditions: Optional[List[V1alpha1ApplicationCondition]] = Field(
        None, title='Conditions is a list of currently observed application conditions'
    )
    health: Optional[V1alpha1HealthStatus] = None
    history: Optional[List[V1alpha1RevisionHistory]] = Field(
        None, title="History contains information about the application's sync history"
    )
    observed_at: Optional[V1Time] = Field(None, alias='observedAt')
    operation_state: Optional[V1alpha1OperationState] = Field(None, alias='operationState')
    reconciled_at: Optional[V1Time] = Field(None, alias='reconciledAt')
    resource_health_source: Optional[str] = Field(
        None,
        alias='resourceHealthSource',
        title=(
            'ResourceHealthSource indicates where the resource health status is stored: inline if not set or appTree'
        ),
    )
    resources: Optional[List[V1alpha1ResourceStatus]] = Field(
        None, title='Resources is a list of Kubernetes resources managed by this application'
    )
    source_type: Optional[str] = Field(
        None, alias='sourceType', title='SourceType specifies the type of this application'
    )
    source_types: Optional[List[str]] = Field(
        None, alias='sourceTypes', title='SourceTypes specifies the type of the sources included in the application'
    )
    summary: Optional[V1alpha1ApplicationSummary] = None
    sync: Optional[V1alpha1SyncStatus] = None


class V1alpha1MatrixGenerator(BaseModel):
    generators: Optional[List[V1alpha1ApplicationSetNestedGenerator]] = None
    template: Optional[V1alpha1ApplicationSetTemplate] = None


class V1alpha1MergeGenerator(BaseModel):
    generators: Optional[List[V1alpha1ApplicationSetNestedGenerator]] = None
    merge_keys: Optional[List[str]] = Field(None, alias='mergeKeys')
    template: Optional[V1alpha1ApplicationSetTemplate] = None


class V1alpha1Application(BaseModel):
    metadata: Optional[V1ObjectMeta] = None
    operation: Optional[V1alpha1Operation] = None
    spec: Optional[V1alpha1ApplicationSpec] = None
    status: Optional[V1alpha1ApplicationStatus] = None


class V1alpha1ApplicationList(BaseModel):
    items: Optional[List[V1alpha1Application]] = None
    metadata: Optional[V1ListMeta] = None


class V1alpha1ApplicationSetGenerator(BaseModel):
    cluster_decision_resource: Optional[V1alpha1DuckTypeGenerator] = Field(None, alias='clusterDecisionResource')
    clusters: Optional[V1alpha1ClusterGenerator] = None
    git: Optional[V1alpha1GitGenerator] = None
    list: Optional[V1alpha1ListGenerator] = None
    matrix: Optional[V1alpha1MatrixGenerator] = None
    merge: Optional[V1alpha1MergeGenerator] = None
    pull_request: Optional[V1alpha1PullRequestGenerator] = Field(None, alias='pullRequest')
    scm_provider: Optional[V1alpha1SCMProviderGenerator] = Field(None, alias='scmProvider')
    selector: Optional[V1LabelSelector] = None


class V1alpha1ApplicationSetSpec(BaseModel):
    generators: Optional[List[V1alpha1ApplicationSetGenerator]] = None
    go_template: Optional[bool] = Field(None, alias='goTemplate')
    preserved_fields: Optional[V1alpha1ApplicationPreservedFields] = Field(None, alias='preservedFields')
    strategy: Optional[V1alpha1ApplicationSetStrategy] = None
    sync_policy: Optional[V1alpha1ApplicationSetSyncPolicy] = Field(None, alias='syncPolicy')
    template: Optional[V1alpha1ApplicationSetTemplate] = None


class V1alpha1ApplicationWatchEvent(BaseModel):
    application: Optional[V1alpha1Application] = None
    type: Optional[str] = None


class V1alpha1ApplicationSet(BaseModel):
    metadata: Optional[V1ObjectMeta] = None
    spec: Optional[V1alpha1ApplicationSetSpec] = None
    status: Optional[V1alpha1ApplicationSetStatus] = None


class V1alpha1ApplicationSetList(BaseModel):
    items: Optional[List[V1alpha1ApplicationSet]] = None
    metadata: Optional[V1ListMeta] = None


class ApplicationsetApplicationSetResponse(BaseModel):
    applicationset: Optional[V1alpha1ApplicationSet] = None
    project: Optional[str] = None
